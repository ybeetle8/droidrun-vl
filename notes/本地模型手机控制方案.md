# 本地模型手机控制方案

## 一、核心设计思路

### 1.1 挑战与约束
- **本地模型上下文限制**：通常 4K-32K tokens，远小于云端模型
- **推理速度**：需要控制单次推理时间在可接受范围（< 10秒）
- **多模态能力**：截图 + UI状态 JSON 会快速消耗 token
- **任务复杂度**：需要将复杂任务拆解为简单的单步操作

### 1.2 设计原则
1. **状态压缩优先**：精简 UI 状态信息，只保留可操作元素
2. **单步决策模式**：每次只让模型决策下一步操作，不规划长期计划
3. **工具调用优化**：使用结构化输出（JSON）而非自然语言
4. **视觉理解可选**：简单任务只用 UI 状态，复杂任务才加载截图
5. **状态缓存机制**：相似场景复用决策，减少推理次数

---

## 二、架构设计

### 2.1 简化的两层架构

```
┌─────────────────────────────────────┐
│     ControlLoop (控制循环)          │
│  - 任务目标管理                      │
│  - 终止条件判断                      │
│  - 历史记录（滑动窗口）              │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│    ActionAgent (动作代理)           │
│  - 接收当前状态                      │
│  - 决策下一步操作                    │
│  - 返回工具调用（JSON）              │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│      ToolExecutor (工具执行器)      │
│  - 执行点击、滑动、输入等操作        │
│  - 返回执行结果                      │
└─────────────────────────────────────┘
```

**去掉 PlannerAgent**：
- 本地模型做长期规划效果差，且消耗大量 token
- 改为在 ControlLoop 中维护简单的任务目标即可

### 2.2 核心组件

#### A. ControlLoop（控制循环）
```python
class ControlLoop:
    """
    控制循环，管理任务执行
    """
    def __init__(self, goal: str, max_steps: int = 20):
        self.goal = goal  # 任务目标
        self.max_steps = max_steps  # 最大步数
        self.history = []  # 操作历史（滑动窗口，只保留最近5步）
        self.step_count = 0

    def should_stop(self, state: dict, last_action: dict) -> bool:
        """判断是否应该停止"""
        # 1. 达到最大步数
        # 2. 重复操作检测（连续3次相同操作）
        # 3. 目标完成检测（简单关键词匹配或让模型判断）
        pass

    def run(self):
        """主循环"""
        while not self.should_stop():
            state = self.get_current_state()  # 获取状态
            action = self.agent.decide(state, self.goal, self.history)  # 决策
            result = self.execute(action)  # 执行
            self.history.append((state, action, result))  # 记录
            self.step_count += 1
```

#### B. ActionAgent（动作代理）
```python
class ActionAgent:
    """
    动作代理，负责单步决策
    """
    def __init__(self, llm, use_vision: bool = False):
        self.llm = llm
        self.use_vision = use_vision

    def decide(self, state: dict, goal: str, history: list) -> dict:
        """
        决策下一步操作

        Returns:
            {
                "action": "click|swipe|input|wait|finish",
                "params": {...}
            }
        """
        prompt = self._build_prompt(state, goal, history)
        response = self.llm.chat(prompt)
        return self._parse_action(response)

    def _build_prompt(self, state, goal, history):
        """构建提示词（核心优化点）"""
        # 1. 压缩 UI 状态（只保留可操作元素）
        # 2. 历史只保留最近3步
        # 3. 明确要求返回 JSON 格式
        pass
```

#### C. StateCompressor（状态压缩器）
```python
class StateCompressor:
    """
    压缩 UI 状态信息，减少 token 消耗
    """
    @staticmethod
    def compress(state_data: dict, keep_vision: bool = False) -> dict:
        """
        压缩策略：
        1. 只保留可操作元素（clickable=True, long_clickable=True, scrollable=True）
        2. 移除冗余字段（class, package 等）
        3. 合并相邻的同类元素（如列表项）
        4. 截图可选（需要时才编码为 base64）

        Returns:
            {
                "screen_size": [1080, 1920],
                "clickable_elements": [
                    {"index": 0, "text": "搜索", "bounds": [x, y, w, h], "type": "button"},
                    {"index": 1, "text": "商品1", "bounds": [...], "type": "item"}
                ],
                "scrollable_areas": [{"bounds": [...], "direction": "vertical"}],
                "current_activity": "com.example.MainActivity"
            }
        """
        compressed = {
            "screen_size": state_data.get("screen_size", [1080, 1920]),
            "clickable_elements": [],
            "scrollable_areas": [],
            "current_activity": state_data.get("activity", "")
        }

        # 遍历 UI 树，提取可操作元素
        for node in state_data.get("nodes", []):
            if node.get("clickable") or node.get("text"):
                compressed["clickable_elements"].append({
                    "index": len(compressed["clickable_elements"]),
                    "text": node.get("text", ""),
                    "content_desc": node.get("content_desc", ""),
                    "bounds": node.get("bounds"),
                    "type": StateCompressor._infer_type(node)
                })

            if node.get("scrollable"):
                compressed["scrollable_areas"].append({
                    "bounds": node.get("bounds"),
                    "direction": "vertical" if node.get("bounds")[3] > node.get("bounds")[2] else "horizontal"
                })

        return compressed

    @staticmethod
    def _infer_type(node: dict) -> str:
        """推断元素类型"""
        class_name = node.get("class", "").lower()
        if "button" in class_name:
            return "button"
        elif "edittext" in class_name:
            return "input"
        elif "textview" in class_name:
            return "text"
        elif "image" in class_name:
            return "image"
        else:
            return "unknown"
```

---

## 三、提示词设计（关键）

### 3.1 系统提示词
```
你是一个手机操作助手，能够理解用户需求并控制手机完成任务。

**操作规则：**
1. 每次只返回一个操作，使用严格的JSON格式
2. 可用操作类型：click（点击）、swipe（滑动）、input（输入）、wait（等待）、finish（完成）
3. 优先使用index索引进行点击，而不是坐标
4. 操作前仔细检查UI状态，避免重复操作
5. 如果连续3步无进展，尝试返回上一页或重新规划

**返回格式（必须严格遵守）：**
{
    "thought": "简短的思考过程，一句话",
    "action": "操作类型",
    "params": {具体参数}
}

**示例：**
点击操作：
{
    "thought": "需要点击搜索框输入商品名称",
    "action": "click",
    "params": {"index": 0}
}

滑动操作：
{
    "thought": "需要向下滚动查看更多商品",
    "action": "swipe",
    "params": {"direction": "down", "distance": 500}
}

输入操作：
{
    "thought": "在搜索框中输入'手机'",
    "action": "input",
    "params": {"text": "手机"}
}

完成操作：
{
    "thought": "已找到目标商品，任务完成",
    "action": "finish",
    "params": {}
}
```

### 3.2 用户提示词模板
```python
def build_user_prompt(goal: str, state: dict, history: list) -> str:
    """构建用户提示词"""

    # 历史记录（只保留最近3步）
    recent_history = history[-3:] if len(history) > 3 else history
    history_text = ""
    for i, (s, a, r) in enumerate(recent_history):
        history_text += f"\n第{len(history)-len(recent_history)+i+1}步: {a['action']} -> {r.get('success', False)}"

    # 压缩后的状态
    compressed_state = json.dumps(state, ensure_ascii=False, indent=2)

    prompt = f"""**任务目标：**
{goal}

**历史操作：**{history_text if history_text else "\n（首次操作）"}

**当前屏幕状态：**
```json
{compressed_state}
```

**请决策下一步操作（严格返回JSON格式）：**"""

    return prompt
```

---

## 四、Token 优化策略

### 4.1 输入优化
| 优化项 | 原始 | 优化后 | 节省 |
|--------|------|--------|------|
| UI状态完整JSON | ~2000 tokens | ~300 tokens | 85% |
| 历史记录全部 | ~500 tokens | ~100 tokens | 80% |
| 截图 (可选) | ~800 tokens | 0-800 tokens | 0-100% |
| 系统提示词 | ~400 tokens | ~300 tokens | 25% |
| **总计** | **~3700 tokens** | **~700 tokens** | **81%** |

### 4.2 输出优化
- 限制 max_tokens=200（一个操作不需要长文本）
- 使用 stop_tokens=["```", "\n\n\n"] 提前终止生成
- 要求模型返回结构化 JSON，避免冗长解释

### 4.3 视觉理解按需加载
```python
def should_use_vision(goal: str, state: dict, history: list) -> bool:
    """
    判断是否需要加载截图

    规则：
    1. UI状态中没有文本信息（纯图标界面）
    2. 任务涉及验证码、图片识别
    3. 连续3步操作失败（可能UI解析不准确）
    4. 目标包含"颜色"、"图片"、"样式"等关键词
    """
    # 检查UI状态是否有足够信息
    text_count = sum(1 for elem in state.get("clickable_elements", []) if elem.get("text"))

    if text_count < 3:  # 文本信息太少
        return True

    # 检查任务关键词
    vision_keywords = ["图片", "颜色", "样式", "验证码", "识别", "图标"]
    if any(kw in goal for kw in vision_keywords):
        return True

    # 检查历史失败次数
    if len(history) >= 3 and all(not h[2].get("success") for h in history[-3:]):
        return True

    return False
```

---

## 五、实现示例代码

### 5.1 主控制循环
```python
class SimplePhoneController:
    """简化的手机控制器"""

    def __init__(self, adb_tools, llm, max_steps=20):
        self.adb = adb_tools
        self.llm = llm
        self.max_steps = max_steps
        self.history = []
        self.step_count = 0

    def run(self, goal: str):
        """执行任务"""
        print(f"🎯 任务目标: {goal}")

        while self.step_count < self.max_steps:
            # 1. 获取并压缩状态
            raw_state = self.adb.get_state()
            screenshot = None

            use_vision = should_use_vision(goal, raw_state, self.history)
            if use_vision:
                _, screenshot = self.adb.take_screenshot()

            compressed_state = StateCompressor.compress(raw_state)

            # 2. 构建提示词
            prompt = build_user_prompt(goal, compressed_state, self.history)

            # 3. 调用模型决策
            action = self.decide_action(prompt, screenshot)

            # 4. 执行操作
            result = self.execute_action(action)

            # 5. 记录历史
            self.history.append((compressed_state, action, result))
            self.step_count += 1

            print(f"步骤 {self.step_count}: {action['action']} -> {result.get('success')}")

            # 6. 检查终止条件
            if action['action'] == 'finish':
                print("✅ 任务完成！")
                break

            if self.should_stop(action, result):
                print("⚠️ 检测到循环或卡死，终止执行")
                break

        return self.history

    def decide_action(self, prompt: str, screenshot: bytes = None) -> dict:
        """调用模型决策"""
        messages = []

        if screenshot:
            messages.append(ChatMessage(
                role=MessageRole.USER,
                content=[
                    TextBlock(text=prompt),
                    ImageBlock(image=screenshot)
                ]
            ))
        else:
            messages.append(ChatMessage(
                role=MessageRole.USER,
                content=prompt
            ))

        response = self.llm.chat(
            messages,
            max_tokens=200,
            temperature=0.1,
            frequency_penalty=0.05,
            presence_penalty=0.05
        )

        # 解析JSON
        try:
            action = json.loads(response.message.content)
            return action
        except:
            print(f"❌ 模型返回格式错误: {response.message.content}")
            return {"action": "wait", "params": {}}

    def execute_action(self, action: dict) -> dict:
        """执行操作"""
        action_type = action.get("action")
        params = action.get("params", {})

        try:
            if action_type == "click":
                if "index" in params:
                    result = self.adb.click(index=params["index"])
                else:
                    result = self.adb.click(x=params["x"], y=params["y"])
                return {"success": True, "result": result}

            elif action_type == "swipe":
                direction = params.get("direction", "down")
                distance = params.get("distance", 500)
                result = self.adb.swipe(direction=direction, distance=distance)
                return {"success": True, "result": result}

            elif action_type == "input":
                text = params.get("text", "")
                result = self.adb.input_text(text)
                return {"success": True, "result": result}

            elif action_type == "wait":
                import time
                time.sleep(2)
                return {"success": True}

            elif action_type == "finish":
                return {"success": True}

            else:
                return {"success": False, "error": "未知操作类型"}

        except Exception as e:
            return {"success": False, "error": str(e)}

    def should_stop(self, action: dict, result: dict) -> bool:
        """判断是否应该停止"""
        # 1. 连续失败检测
        if len(self.history) >= 3:
            recent_failures = [not h[2].get("success") for h in self.history[-3:]]
            if all(recent_failures):
                return True

        # 2. 重复操作检测
        if len(self.history) >= 3:
            recent_actions = [h[1].get("action") for h in self.history[-3:]]
            if len(set(recent_actions)) == 1:  # 连续3次相同操作
                return True

        return False
```

### 5.2 使用示例
```python
# 配置
API_BASE = "http://192.168.18.9:8080/v1"
MODEL = "/models"

# 初始化
adb = AdbTools(use_tcp=True)
llm = load_llm(
    provider_name="OpenAILike",
    model=MODEL,
    api_base=API_BASE,
    temperature=0.1,
    max_tokens=200
)

# 创建控制器
controller = SimplePhoneController(adb, llm, max_steps=20)

# 执行任务
controller.run("打开淘宝，搜索'手机'，点击第一个商品")
```

---

## 六、进阶优化

### 6.1 动作缓存（相似场景复用）
```python
class ActionCache:
    """缓存相似场景的决策结果"""

    def __init__(self, similarity_threshold=0.8):
        self.cache = {}  # {state_hash: action}
        self.threshold = similarity_threshold

    def get(self, state: dict) -> dict | None:
        """查找相似状态的缓存决策"""
        state_hash = self._hash_state(state)
        return self.cache.get(state_hash)

    def set(self, state: dict, action: dict):
        """缓存决策"""
        state_hash = self._hash_state(state)
        self.cache[state_hash] = action

    def _hash_state(self, state: dict) -> str:
        """计算状态哈希（简化版）"""
        # 提取关键特征：activity + 可点击元素的文本
        key_features = [
            state.get("current_activity", ""),
            *[elem.get("text", "") for elem in state.get("clickable_elements", [])]
        ]
        return "|".join(key_features)
```

### 6.2 失败重试机制
```python
class RetryWrapper:
    """失败重试包装器"""

    def __init__(self, max_retries=2):
        self.max_retries = max_retries

    def execute_with_retry(self, func, *args, **kwargs):
        """执行操作，失败时重试"""
        for attempt in range(self.max_retries + 1):
            try:
                result = func(*args, **kwargs)
                if result.get("success"):
                    return result
                else:
                    print(f"⚠️ 操作失败，重试 {attempt+1}/{self.max_retries}")
            except Exception as e:
                print(f"❌ 异常: {e}，重试 {attempt+1}/{self.max_retries}")

            if attempt < self.max_retries:
                time.sleep(1)  # 等待1秒后重试

        return {"success": False, "error": "重试次数耗尽"}
```

### 6.3 上下文窗口自适应
```python
def adaptive_history_window(history: list, max_tokens: int = 500) -> list:
    """
    根据token限制动态调整历史窗口大小

    策略：
    1. 优先保留最近的操作
    2. 如果token充足，保留关键操作（如首次点击、输入等）
    3. 压缩中间步骤（只保留action类型，去掉详细state）
    """
    if len(history) <= 3:
        return history

    # 计算每条历史的token消耗（简化估算）
    def estimate_tokens(item):
        state, action, result = item
        return len(json.dumps(state)) // 4 + len(json.dumps(action)) // 4

    # 总是保留最近3步
    recent = history[-3:]
    remaining_tokens = max_tokens - sum(estimate_tokens(h) for h in recent)

    # 尝试添加更早的关键步骤
    key_actions = ["click", "input"]
    selected = []
    for item in reversed(history[:-3]):
        if item[1].get("action") in key_actions and remaining_tokens > 0:
            tokens = estimate_tokens(item)
            if tokens <= remaining_tokens:
                selected.insert(0, item)
                remaining_tokens -= tokens

    return selected + recent
```

---

## 七、性能预期

### 7.1 Token 消耗
- **单步决策**: 约 700-1500 tokens（不含截图）/ 1500-2300 tokens（含截图）
- **20步任务**: 约 14K-30K tokens（4K 上下文可能不够，建议 8K 以上）

### 7.2 速度预期
- **本地推理速度**: 假设 10 tokens/s，单步决策 70-230 秒（太慢！）
- **优化建议**: 使用量化模型（Q4/Q8）+ GPU加速，目标 30-50 tokens/s

### 7.3 准确率预期
- **简单任务**（点击、滑动）: 80-90%
- **中等任务**（搜索商品、浏览）: 60-70%
- **复杂任务**（多步流程、条件判断）: 40-50%

---

## 八、推荐模型

| 模型 | 参数量 | 上下文 | 多模态 | 推荐度 |
|------|--------|--------|--------|--------|
| Qwen2-VL-7B | 7B | 32K | ✅ | ⭐⭐⭐⭐⭐ |
| LLaVA-v1.6-34B | 34B | 4K | ✅ | ⭐⭐⭐⭐ |
| InternVL2-8B | 8B | 8K | ✅ | ⭐⭐⭐⭐ |
| MiniCPM-V-2.6 | 8B | 8K | ✅ | ⭐⭐⭐⭐ |

**推荐配置**：
- **首选**: Qwen2-VL-7B (支持长上下文，多模态能力强)
- **量化**: Q4_K_M（速度和精度平衡）
- **硬件**: RTX 3090/4090 或更高

---

## 九、总结

### 核心要点
1. **化繁为简**: 去掉复杂的规划层，改为单步决策
2. **状态压缩**: UI状态从2000 tokens压缩到300 tokens
3. **按需视觉**: 只在必要时使用截图，节省token
4. **结构化输出**: 要求JSON格式，避免冗长解释
5. **滑动窗口**: 历史记录只保留最近3-5步

### 实现优先级
1. ✅ **P0**: 实现 StateCompressor（状态压缩器）
2. ✅ **P0**: 实现 SimplePhoneController（简单控制循环）
3. ✅ **P0**: 设计高效提示词模板
4. ⚠️ **P1**: 添加视觉理解按需加载逻辑
5. ⚠️ **P1**: 实现失败重试和循环检测
6. ⏸️ **P2**: 添加动作缓存优化
7. ⏸️ **P2**: 实现自适应历史窗口

### 下一步行动
1. 基于 `test_screen_analysis.py` 实现 `StateCompressor`
2. 编写单步决策的提示词模板
3. 测试不同压缩级别下的模型表现
4. 评估是否需要引入 Few-Shot 示例（会增加 token）

---

**关键权衡**：
- 本地模型 = 速度慢 + 上下文小 + 能力弱
- 解决方案 = 简化架构 + 压缩输入 + 单步决策
- 目标：在 8K 上下文内完成 10-20 步的简单任务

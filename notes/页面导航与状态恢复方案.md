# é¡µé¢å¯¼èˆªä¸çŠ¶æ€æ¢å¤æ–¹æ¡ˆ

## ä¸€ã€é—®é¢˜åˆ†æ

### 1.1 æ ¸å¿ƒæŒ‘æˆ˜
1. **æ·±å±‚é¡µé¢åµŒå¥—**ï¼šä»»åŠ¡æ‰§è¡Œå¯èƒ½è¿›å…¥å¤šå±‚å­é¡µé¢ï¼ˆå¦‚ï¼šé¦–é¡µ â†’ åˆ†ç±» â†’ å•†å“è¯¦æƒ… â†’ è¯„è®º â†’ å›¾ç‰‡æŸ¥çœ‹ï¼‰
2. **ä»»åŠ¡å®Œæˆåè¿·å¤±**ï¼šä¸çŸ¥é“å½“å‰åœ¨å“ªï¼Œä¹Ÿä¸çŸ¥é“å¦‚ä½•å›åˆ°èµ·ç‚¹
3. **ä¸‹æ¬¡ä»»åŠ¡èµ·ç‚¹ä¸æ˜ç¡®**ï¼šä¸‹ä¸€ä¸ªä»»åŠ¡åº”è¯¥ä»å“ªä¸ªé¡µé¢å¼€å§‹ï¼Ÿ
4. **é¡µé¢è¯†åˆ«å›°éš¾**ï¼šå¦‚ä½•åˆ¤æ–­"å·²ç»åˆ°è¾¾ç›®æ ‡é¡µé¢"ï¼Ÿ

### 1.2 å…¸å‹åœºæ™¯
```
åœºæ™¯1: è¿ç»­ä»»åŠ¡
- ä»»åŠ¡1: åœ¨æ·˜å®æœç´¢"æ‰‹æœº" â†’ è¿›å…¥äº†å•†å“è¯¦æƒ…é¡µ
- ä»»åŠ¡2: æœç´¢"è€³æœº" â†’ éœ€è¦å…ˆå›åˆ°é¦–é¡µæˆ–æœç´¢é¡µ

åœºæ™¯2: ä»»åŠ¡ä¸­æ–­
- ä»»åŠ¡: æµè§ˆå•†å“ â†’ ç‚¹äº†å¥½å‡ å±‚ â†’ æƒ³æ”¾å¼ƒä»»åŠ¡å›åˆ°é¦–é¡µ

åœºæ™¯3: åº”ç”¨åˆ‡æ¢
- ä»»åŠ¡1: åœ¨æ·˜å®æœç´¢å•†å“
- ä»»åŠ¡2: åœ¨äº¬ä¸œæœç´¢å•†å“ â†’ éœ€è¦å…ˆé€€å‡ºæ·˜å®ï¼Œæ‰“å¼€äº¬ä¸œ
```

---

## äºŒã€è§£å†³æ–¹æ¡ˆè®¾è®¡

### 2.1 æ ¸å¿ƒæ€è·¯ï¼šå¯¼èˆªé”šç‚¹ï¼ˆNavigation Anchorï¼‰

**å®šä¹‰å¯¼èˆªé”šç‚¹**ï¼šæ¯ä¸ªä»»åŠ¡å¼€å§‹å‰ï¼Œå®šä¹‰ä¸€ä¸ª"èµ·å§‹é¡µé¢"ä½œä¸ºé”šç‚¹ã€‚

```python
class NavigationAnchor:
    """å¯¼èˆªé”šç‚¹ï¼Œå®šä¹‰ä»»åŠ¡çš„èµ·å§‹é¡µé¢"""

    def __init__(self,
                 app_package: str,           # åº”ç”¨åŒ…å
                 anchor_page: str,           # é”šç‚¹é¡µé¢æ ‡è¯†
                 verification_rules: dict):   # é¡µé¢éªŒè¯è§„åˆ™
        self.app_package = app_package
        self.anchor_page = anchor_page
        self.verification_rules = verification_rules

    def is_at_anchor(self, state: dict) -> bool:
        """åˆ¤æ–­å½“å‰æ˜¯å¦åœ¨é”šç‚¹é¡µé¢"""
        pass

# ç¤ºä¾‹ï¼šæ·˜å®æœç´¢é¡µä½œä¸ºé”šç‚¹
taobao_search_anchor = NavigationAnchor(
    app_package="com.taobao.taobao",
    anchor_page="search_home",
    verification_rules={
        "activity_contains": "SearchActivity",
        "elements_contains": ["æœç´¢æ¡†", "æ‰«ä¸€æ‰«", "æ‹ç…§è´­"],
        "title_regex": r"æœç´¢|æ·˜å®"
    }
)
```

### 2.2 é¡µé¢æ ˆè¿½è¸ªï¼ˆPage Stack Trackingï¼‰

**è®°å½•é¡µé¢å¯¼èˆªè·¯å¾„**ï¼Œåƒæµè§ˆå™¨çš„å‰è¿›/åé€€æŒ‰é’®ã€‚

```python
class PageStackTracker:
    """é¡µé¢æ ˆè¿½è¸ªå™¨"""

    def __init__(self):
        self.page_stack = []  # é¡µé¢æ ˆ
        self.max_depth = 10   # æœ€å¤§è¿½è¸ªæ·±åº¦

    def push_page(self, page_info: dict):
        """è¿›å…¥æ–°é¡µé¢æ—¶è®°å½•"""
        page_snapshot = {
            "activity": page_info.get("current_activity"),
            "title": self._extract_title(page_info),
            "key_elements": self._extract_key_elements(page_info),
            "timestamp": time.time(),
            "depth": len(self.page_stack)
        }

        # æ£€æµ‹æ˜¯å¦çœŸçš„è¿›å…¥äº†æ–°é¡µé¢ï¼ˆé¿å…é‡å¤è®°å½•ï¼‰
        if not self.page_stack or not self._is_same_page(self.page_stack[-1], page_snapshot):
            self.page_stack.append(page_snapshot)

            # é™åˆ¶æ ˆæ·±åº¦
            if len(self.page_stack) > self.max_depth:
                self.page_stack.pop(0)

    def pop_page(self):
        """è¿”å›ä¸Šä¸€é¡µæ—¶å¼¹å‡º"""
        if self.page_stack:
            return self.page_stack.pop()
        return None

    def get_current_depth(self) -> int:
        """è·å–å½“å‰é¡µé¢æ·±åº¦"""
        return len(self.page_stack)

    def _is_same_page(self, page1: dict, page2: dict) -> bool:
        """åˆ¤æ–­æ˜¯å¦æ˜¯åŒä¸€ä¸ªé¡µé¢"""
        # æ¯”è¾ƒ activity å’Œå…³é”®å…ƒç´ 
        return (page1["activity"] == page2["activity"] and
                set(page1["key_elements"]) == set(page2["key_elements"]))

    def _extract_title(self, state: dict) -> str:
        """æå–é¡µé¢æ ‡é¢˜"""
        # ä»UIçŠ¶æ€ä¸­æ‰¾æ ‡é¢˜æ æ–‡æœ¬
        for elem in state.get("clickable_elements", []):
            if "title" in elem.get("type", "").lower():
                return elem.get("text", "")
        return ""

    def _extract_key_elements(self, state: dict) -> list:
        """æå–é¡µé¢å…³é”®å…ƒç´ ï¼ˆç”¨äºè¯†åˆ«é¡µé¢ï¼‰"""
        # æå–å‰5ä¸ªå¯ç‚¹å‡»å…ƒç´ çš„æ–‡æœ¬ä½œä¸ºé¡µé¢ç‰¹å¾
        elements = []
        for elem in state.get("clickable_elements", [])[:5]:
            text = elem.get("text", "").strip()
            if text:
                elements.append(text)
        return elements
```

### 2.3 æ™ºèƒ½è¿”å›å¯¼èˆªå™¨ï¼ˆSmart Back Navigatorï¼‰

**æ ¸å¿ƒç»„ä»¶**ï¼šè´Ÿè´£å°†é¡µé¢å¯¼èˆªå›é”šç‚¹ã€‚

```python
class SmartBackNavigator:
    """æ™ºèƒ½è¿”å›å¯¼èˆªå™¨"""

    def __init__(self, adb_tools, llm=None):
        self.adb = adb_tools
        self.llm = llm  # å¯é€‰ï¼šç”¨äºå¤æ‚å¯¼èˆªå†³ç­–
        self.page_tracker = PageStackTracker()

    def navigate_to_anchor(self, anchor: NavigationAnchor, max_attempts: int = 10) -> bool:
        """
        å¯¼èˆªå›é”šç‚¹é¡µé¢

        ç­–ç•¥ä¼˜å…ˆçº§ï¼š
        1. æ£€æŸ¥æ˜¯å¦å·²åœ¨é”šç‚¹ â†’ ç›´æ¥è¿”å›
        2. å°è¯•æŒ‰è¿”å›é”®ï¼ˆåŸºäºé¡µé¢æ ˆæ·±åº¦ï¼‰
        3. å°è¯•ç‚¹å‡»"é¦–é¡µ"ã€"è¿”å›"æŒ‰é’®
        4. é‡å¯åº”ç”¨åˆ°é¦–é¡µ
        5. å¦‚æœé”šç‚¹ä¸æ˜¯é¦–é¡µï¼Œä½¿ç”¨LLMå¼•å¯¼

        Returns:
            bool: æ˜¯å¦æˆåŠŸåˆ°è¾¾é”šç‚¹
        """
        print(f"ğŸ¯ å¼€å§‹å¯¼èˆªåˆ°é”šç‚¹: {anchor.anchor_page}")

        for attempt in range(max_attempts):
            # è·å–å½“å‰çŠ¶æ€
            state = self.adb.get_state()
            compressed_state = StateCompressor.compress(state)

            # ç­–ç•¥1: æ£€æŸ¥æ˜¯å¦å·²åœ¨é”šç‚¹
            if anchor.is_at_anchor(compressed_state):
                print(f"âœ… å·²åˆ°è¾¾é”šç‚¹é¡µé¢")
                return True

            print(f"ğŸ“ å°è¯• {attempt + 1}/{max_attempts}: å½“å‰é¡µé¢æ·±åº¦ {self.page_tracker.get_current_depth()}")

            # ç­–ç•¥2: ä½¿ç”¨è¿”å›é”®ï¼ˆåŸºäºé¡µé¢æ ˆï¼‰
            if self.page_tracker.get_current_depth() > 0:
                success = self._try_back_button(compressed_state)
                if success:
                    self.page_tracker.pop_page()
                    time.sleep(1)
                    continue

            # ç­–ç•¥3: å°è¯•ç‚¹å‡»å¯¼èˆªæŒ‰é’®
            success = self._try_navigation_buttons(compressed_state, anchor)
            if success:
                time.sleep(1)
                continue

            # ç­–ç•¥4: é‡å¯åº”ç”¨
            if attempt >= max_attempts // 2:
                print("âš ï¸ å°è¯•é‡å¯åº”ç”¨...")
                self._restart_app(anchor.app_package)
                time.sleep(2)
                continue

            # ç­–ç•¥5: LLMè¾…åŠ©å¯¼èˆªï¼ˆæœ€åæ‰‹æ®µï¼‰
            if self.llm and attempt >= max_attempts - 2:
                success = self._llm_guided_navigation(compressed_state, anchor)
                if success:
                    time.sleep(1)
                    continue

            # éƒ½å¤±è´¥äº†ï¼Œç­‰å¾…ä¸€ä¸‹é‡è¯•
            time.sleep(1)

        print(f"âŒ æ— æ³•å¯¼èˆªåˆ°é”šç‚¹")
        return False

    def _try_back_button(self, state: dict) -> bool:
        """å°è¯•ä½¿ç”¨è¿”å›é”®"""
        try:
            print("  â†’ å°è¯•è¿”å›é”®")
            self.adb.press_back()
            return True
        except:
            return False

    def _try_navigation_buttons(self, state: dict, anchor: NavigationAnchor) -> bool:
        """å°è¯•ç‚¹å‡»å¯¼èˆªæŒ‰é’®ï¼ˆé¦–é¡µã€è¿”å›ç­‰ï¼‰"""
        # å®šä¹‰å¯¼èˆªå…³é”®è¯
        nav_keywords = ["é¦–é¡µ", "ä¸»é¡µ", "è¿”å›", "home", "back", "å–æ¶ˆ", "å…³é—­"]

        for elem in state.get("clickable_elements", []):
            text = elem.get("text", "").lower()
            desc = elem.get("content_desc", "").lower()

            # æ£€æŸ¥æ˜¯å¦æ˜¯å¯¼èˆªæŒ‰é’®
            for keyword in nav_keywords:
                if keyword in text or keyword in desc:
                    try:
                        print(f"  â†’ å°è¯•ç‚¹å‡»å¯¼èˆªæŒ‰é’®: {elem.get('text', elem.get('content_desc'))}")
                        self.adb.click(index=elem["index"])
                        return True
                    except:
                        pass

        return False

    def _restart_app(self, package: str):
        """é‡å¯åº”ç”¨"""
        try:
            # å¼ºåˆ¶åœæ­¢
            self.adb.device.app_stop(package)
            time.sleep(1)
            # é‡æ–°å¯åŠ¨
            self.adb.device.app_start(package)
            # æ¸…ç©ºé¡µé¢æ ˆ
            self.page_tracker.page_stack.clear()
        except Exception as e:
            print(f"âš ï¸ é‡å¯åº”ç”¨å¤±è´¥: {e}")

    def _llm_guided_navigation(self, state: dict, anchor: NavigationAnchor) -> bool:
        """ä½¿ç”¨LLMå¼•å¯¼å¯¼èˆªï¼ˆæœ€åæ‰‹æ®µï¼‰"""
        if not self.llm:
            return False

        prompt = f"""å½“å‰é¡µé¢çŠ¶æ€ï¼š
{json.dumps(state, ensure_ascii=False, indent=2)}

ç›®æ ‡ï¼šå¯¼èˆªåˆ° {anchor.anchor_page} é¡µé¢

è¯·åˆ¤æ–­åº”è¯¥æ‰§è¡Œä»€ä¹ˆæ“ä½œæ‰èƒ½æ›´æ¥è¿‘ç›®æ ‡é¡µé¢ã€‚è¿”å›JSONæ ¼å¼ï¼š
{{
    "action": "click|back|home",
    "params": {{"index": 0}} æˆ– {{}}
}}
"""

        try:
            response = self.llm.chat(prompt)
            action = json.loads(response)

            if action["action"] == "click":
                self.adb.click(index=action["params"]["index"])
                return True
            elif action["action"] == "back":
                self.adb.press_back()
                return True
            elif action["action"] == "home":
                self.adb.press_home()
                time.sleep(1)
                self.adb.device.app_start(anchor.app_package)
                return True
        except:
            pass

        return False
```

### 2.4 é¡µé¢éªŒè¯å™¨ï¼ˆPage Verifierï¼‰

**ç”¨äºåˆ¤æ–­"æ˜¯å¦åˆ°è¾¾ç›®æ ‡é¡µé¢"**ã€‚

```python
class PageVerifier:
    """é¡µé¢éªŒè¯å™¨"""

    @staticmethod
    def verify_page(state: dict, verification_rules: dict) -> bool:
        """
        æ ¹æ®è§„åˆ™éªŒè¯é¡µé¢

        æ”¯æŒçš„éªŒè¯è§„åˆ™ï¼š
        - activity_contains: Activityåç§°åŒ…å«å…³é”®è¯
        - activity_equals: Activityåç§°å®Œå…¨åŒ¹é…
        - elements_contains: é¡µé¢åŒ…å«ç‰¹å®šæ–‡æœ¬å…ƒç´ ï¼ˆANDå…³ç³»ï¼‰
        - elements_any: é¡µé¢åŒ…å«ä»»ä¸€æ–‡æœ¬å…ƒç´ ï¼ˆORå…³ç³»ï¼‰
        - title_regex: æ ‡é¢˜åŒ¹é…æ­£åˆ™è¡¨è¾¾å¼
        - package_equals: åŒ…åå®Œå…¨åŒ¹é…
        """
        # æå–å½“å‰é¡µé¢ä¿¡æ¯
        current_activity = state.get("current_activity", "")
        current_package = state.get("package", "")
        elements_texts = [
            elem.get("text", "").lower()
            for elem in state.get("clickable_elements", [])
        ]

        # éªŒè¯ activity
        if "activity_contains" in verification_rules:
            keyword = verification_rules["activity_contains"].lower()
            if keyword not in current_activity.lower():
                return False

        if "activity_equals" in verification_rules:
            if current_activity != verification_rules["activity_equals"]:
                return False

        # éªŒè¯åŒ…å
        if "package_equals" in verification_rules:
            if current_package != verification_rules["package_equals"]:
                return False

        # éªŒè¯å…ƒç´ å­˜åœ¨ï¼ˆANDï¼‰
        if "elements_contains" in verification_rules:
            required = [kw.lower() for kw in verification_rules["elements_contains"]]
            for kw in required:
                if not any(kw in text for text in elements_texts):
                    return False

        # éªŒè¯å…ƒç´ å­˜åœ¨ï¼ˆORï¼‰
        if "elements_any" in verification_rules:
            keywords = [kw.lower() for kw in verification_rules["elements_any"]]
            if not any(any(kw in text for text in elements_texts) for kw in keywords):
                return False

        # éªŒè¯æ ‡é¢˜æ­£åˆ™
        if "title_regex" in verification_rules:
            import re
            title = PageVerifier._extract_title(state)
            if not re.search(verification_rules["title_regex"], title):
                return False

        return True

    @staticmethod
    def _extract_title(state: dict) -> str:
        """æå–é¡µé¢æ ‡é¢˜"""
        # ä¼˜å…ˆæŸ¥æ‰¾é¡¶éƒ¨çš„æ–‡æœ¬å…ƒç´ 
        for elem in state.get("clickable_elements", [])[:5]:
            if elem.get("bounds", [0, 0, 0, 0])[1] < 200:  # é¡¶éƒ¨åŒºåŸŸ
                text = elem.get("text", "").strip()
                if text:
                    return text
        return ""
```

---

## ä¸‰ã€é›†æˆåˆ°æ§åˆ¶å™¨

### 3.1 å¢å¼ºçš„æ§åˆ¶å™¨

```python
class NavigationAwareController:
    """æ”¯æŒå¯¼èˆªçš„æ‰‹æœºæ§åˆ¶å™¨"""

    def __init__(self, adb_tools, llm, max_steps=20):
        self.adb = adb_tools
        self.llm = llm
        self.max_steps = max_steps

        # å¯¼èˆªç»„ä»¶
        self.navigator = SmartBackNavigator(adb_tools, llm)
        self.page_tracker = self.navigator.page_tracker

        # ä»»åŠ¡å†å²
        self.history = []
        self.step_count = 0

    def run_task(self, goal: str, anchor: NavigationAnchor = None):
        """
        æ‰§è¡Œä»»åŠ¡ï¼ˆå¸¦å¯¼èˆªæ”¯æŒï¼‰

        Args:
            goal: ä»»åŠ¡ç›®æ ‡
            anchor: ä»»åŠ¡èµ·å§‹é¡µé¢é”šç‚¹ï¼ˆå¦‚æœä¸ºNoneï¼Œåˆ™ä»å½“å‰é¡µé¢å¼€å§‹ï¼‰
        """
        print(f"ğŸ¯ ä»»åŠ¡: {goal}")

        # 1. å¯¼èˆªåˆ°èµ·å§‹é¡µé¢
        if anchor:
            success = self.navigator.navigate_to_anchor(anchor)
            if not success:
                print("âŒ æ— æ³•å¯¼èˆªåˆ°èµ·å§‹é¡µé¢ï¼Œä»»åŠ¡ç»ˆæ­¢")
                return False
            # é‡ç½®é¡µé¢æ ˆ
            self.page_tracker.page_stack.clear()

        # 2. æ‰§è¡Œä»»åŠ¡ä¸»å¾ªç¯
        task_result = self._execute_task_loop(goal)

        # 3. ä»»åŠ¡å®Œæˆåï¼Œè¿”å›åˆ°é”šç‚¹ï¼ˆå¯é€‰ï¼‰
        if anchor and task_result:
            print("\nğŸ“ ä»»åŠ¡å®Œæˆï¼Œå‡†å¤‡è¿”å›èµ·å§‹é¡µé¢...")
            self.navigator.navigate_to_anchor(anchor)

        return task_result

    def _execute_task_loop(self, goal: str) -> bool:
        """ä»»åŠ¡æ‰§è¡Œä¸»å¾ªç¯"""
        while self.step_count < self.max_steps:
            # è·å–çŠ¶æ€
            state = self.adb.get_state()
            compressed_state = StateCompressor.compress(state)

            # è¿½è¸ªé¡µé¢
            self.page_tracker.push_page(compressed_state)

            # å†³ç­–åŠ¨ä½œ
            action = self.decide_action(goal, compressed_state)

            # æ‰§è¡ŒåŠ¨ä½œ
            result = self.execute_action(action)

            # è®°å½•å†å²
            self.history.append((compressed_state, action, result))
            self.step_count += 1

            print(f"æ­¥éª¤ {self.step_count}: {action['action']} (æ·±åº¦: {self.page_tracker.get_current_depth()})")

            # æ£€æŸ¥ç»ˆæ­¢
            if action['action'] == 'finish':
                print("âœ… ä»»åŠ¡å®Œæˆ")
                return True

            if self.should_stop(action, result):
                print("âš ï¸ ä»»åŠ¡ä¸­æ­¢")
                return False

            time.sleep(1)

        print("âš ï¸ è¾¾åˆ°æœ€å¤§æ­¥æ•°")
        return False

    def decide_action(self, goal: str, state: dict) -> dict:
        """å†³ç­–åŠ¨ä½œï¼ˆçœç•¥ï¼Œå‚è€ƒä¹‹å‰çš„æ–¹æ¡ˆï¼‰"""
        pass

    def execute_action(self, action: dict) -> dict:
        """æ‰§è¡ŒåŠ¨ä½œï¼ˆçœç•¥ï¼Œå‚è€ƒä¹‹å‰çš„æ–¹æ¡ˆï¼‰"""
        pass

    def should_stop(self, action: dict, result: dict) -> bool:
        """åˆ¤æ–­æ˜¯å¦åœæ­¢ï¼ˆçœç•¥ï¼Œå‚è€ƒä¹‹å‰çš„æ–¹æ¡ˆï¼‰"""
        pass
```

### 3.2 é¢„å®šä¹‰å¸¸ç”¨é”šç‚¹

```python
class CommonAnchors:
    """å¸¸ç”¨åº”ç”¨çš„é”šç‚¹å®šä¹‰"""

    # æ·˜å®æœç´¢é¡µ
    TAOBAO_SEARCH = NavigationAnchor(
        app_package="com.taobao.taobao",
        anchor_page="search_home",
        verification_rules={
            "package_equals": "com.taobao.taobao",
            "elements_contains": ["æœç´¢æ¡†", "æ‰«ä¸€æ‰«"],
        }
    )

    # æ·˜å®é¦–é¡µ
    TAOBAO_HOME = NavigationAnchor(
        app_package="com.taobao.taobao",
        anchor_page="main_home",
        verification_rules={
            "package_equals": "com.taobao.taobao",
            "elements_any": ["é¦–é¡µ", "ä¸»é¡µ", "æ·˜å®"],
        }
    )

    # äº¬ä¸œæœç´¢é¡µ
    JD_SEARCH = NavigationAnchor(
        app_package="com.jingdong.app.mall",
        anchor_page="search_home",
        verification_rules={
            "package_equals": "com.jingdong.app.mall",
            "elements_contains": ["æœç´¢"],
        }
    )

    # å¾®ä¿¡èŠå¤©åˆ—è¡¨
    WECHAT_CHAT_LIST = NavigationAnchor(
        app_package="com.tencent.mm",
        anchor_page="chat_list",
        verification_rules={
            "package_equals": "com.tencent.mm",
            "elements_contains": ["å¾®ä¿¡", "é€šè®¯å½•"],
        }
    )

    @staticmethod
    def get_anchor(app_name: str, page_name: str = "home") -> NavigationAnchor:
        """æ ¹æ®åº”ç”¨åè·å–é”šç‚¹"""
        anchors = {
            "taobao": {
                "home": CommonAnchors.TAOBAO_HOME,
                "search": CommonAnchors.TAOBAO_SEARCH,
            },
            "jd": {
                "search": CommonAnchors.JD_SEARCH,
            },
            "wechat": {
                "chat_list": CommonAnchors.WECHAT_CHAT_LIST,
            }
        }

        return anchors.get(app_name, {}).get(page_name)
```

---

## å››ã€ä½¿ç”¨ç¤ºä¾‹

### 4.1 åŸºç¡€ä½¿ç”¨

```python
# åˆå§‹åŒ–
adb = AdbTools(use_tcp=True)
llm = load_llm(provider_name="OpenAILike", model="/models", ...)
controller = NavigationAwareController(adb, llm)

# åœºæ™¯1: å•ä¸ªä»»åŠ¡ï¼ˆè‡ªåŠ¨è¿”å›èµ·ç‚¹ï¼‰
anchor = CommonAnchors.TAOBAO_SEARCH
controller.run_task("æœç´¢'æ‰‹æœº'ï¼Œç‚¹å‡»ç¬¬ä¸€ä¸ªå•†å“æŸ¥çœ‹è¯¦æƒ…", anchor=anchor)
# ä»»åŠ¡å®Œæˆåä¼šè‡ªåŠ¨è¿”å›æœç´¢é¡µ

# åœºæ™¯2: è¿ç»­ä»»åŠ¡
controller.run_task("æœç´¢'æ‰‹æœº'", anchor=anchor)
controller.run_task("æœç´¢'è€³æœº'", anchor=anchor)  # ä¼šå…ˆè¿”å›æœç´¢é¡µå†æ‰§è¡Œ

# åœºæ™¯3: ä¸æŒ‡å®šé”šç‚¹ï¼ˆä»å½“å‰é¡µé¢å¼€å§‹ï¼‰
controller.run_task("ç‚¹å‡»ç¬¬ä¸€ä¸ªå•†å“")  # ä»å½“å‰é¡µé¢å¼€å§‹ï¼Œå®Œæˆååœç•™åœ¨ç»“æœé¡µ
```

### 4.2 å¤šåº”ç”¨åˆ‡æ¢

```python
class MultiAppController:
    """å¤šåº”ç”¨ä»»åŠ¡æ§åˆ¶å™¨"""

    def __init__(self, adb_tools, llm):
        self.controller = NavigationAwareController(adb_tools, llm)

    def run_multi_app_tasks(self, tasks: list):
        """
        æ‰§è¡Œè·¨åº”ç”¨ä»»åŠ¡åˆ—è¡¨

        Args:
            tasks: [
                {"app": "taobao", "goal": "æœç´¢æ‰‹æœº", "anchor": "search"},
                {"app": "jd", "goal": "æœç´¢è€³æœº", "anchor": "search"},
            ]
        """
        for task in tasks:
            app_name = task["app"]
            goal = task["goal"]
            anchor_name = task.get("anchor", "home")

            # è·å–é”šç‚¹
            anchor = CommonAnchors.get_anchor(app_name, anchor_name)

            if not anchor:
                print(f"âš ï¸ æœªæ‰¾åˆ°åº”ç”¨ {app_name} çš„é”šç‚¹ {anchor_name}")
                continue

            print(f"\n{'='*60}")
            print(f"ğŸš€ åˆ‡æ¢åˆ° {app_name} æ‰§è¡Œä»»åŠ¡: {goal}")
            print(f"{'='*60}")

            # æ‰§è¡Œä»»åŠ¡
            success = self.controller.run_task(goal, anchor=anchor)

            if not success:
                print(f"âŒ ä»»åŠ¡å¤±è´¥: {goal}")
            else:
                print(f"âœ… ä»»åŠ¡å®Œæˆ: {goal}")

# ä½¿ç”¨
multi_controller = MultiAppController(adb, llm)
multi_controller.run_multi_app_tasks([
    {"app": "taobao", "goal": "æœç´¢'æ‰‹æœº'ï¼ŒæŸ¥çœ‹å‰3ä¸ªå•†å“ä»·æ ¼", "anchor": "search"},
    {"app": "jd", "goal": "æœç´¢'æ‰‹æœº'ï¼ŒæŸ¥çœ‹å‰3ä¸ªå•†å“ä»·æ ¼", "anchor": "search"},
    {"app": "taobao", "goal": "å¯¹æ¯”ä»·æ ¼ï¼Œé€‰æ‹©æœ€ä¾¿å®œçš„", "anchor": "search"},
])
```

### 4.3 ç´§æ€¥è¿”å›åŠŸèƒ½

```python
def emergency_return_home(adb_tools):
    """ç´§æ€¥è¿”å›æ¡Œé¢ï¼ˆä»»åŠ¡å¤±æ§æ—¶ä½¿ç”¨ï¼‰"""
    print("ğŸš¨ ç´§æ€¥è¿”å›æ¡Œé¢...")
    adb_tools.press_home()
    time.sleep(1)

def emergency_return_app_home(adb_tools, package: str):
    """ç´§æ€¥è¿”å›åº”ç”¨é¦–é¡µ"""
    print(f"ğŸš¨ ç´§æ€¥è¿”å› {package} é¦–é¡µ...")
    # æ–¹æ³•1: å¤šæ¬¡è¿”å›é”®
    for _ in range(5):
        adb_tools.press_back()
        time.sleep(0.5)

    # æ–¹æ³•2: é‡å¯åº”ç”¨
    adb_tools.device.app_stop(package)
    time.sleep(1)
    adb_tools.device.app_start(package)
```

---

## äº”ã€é«˜çº§ä¼˜åŒ–

### 5.1 é¡µé¢æŒ‡çº¹è¯†åˆ«ï¼ˆå¿«é€Ÿåˆ¤æ–­é¡µé¢ï¼‰

```python
class PageFingerprint:
    """é¡µé¢æŒ‡çº¹ï¼Œç”¨äºå¿«é€Ÿè¯†åˆ«é¡µé¢"""

    @staticmethod
    def generate(state: dict) -> str:
        """ç”Ÿæˆé¡µé¢æŒ‡çº¹"""
        # ç‰¹å¾1: Activity
        activity = state.get("current_activity", "")

        # ç‰¹å¾2: å…³é”®å…ƒç´ æ–‡æœ¬ï¼ˆå‰5ä¸ªï¼‰
        elements = []
        for elem in state.get("clickable_elements", [])[:5]:
            text = elem.get("text", "").strip()
            if text:
                elements.append(text)

        # ç‰¹å¾3: å¸ƒå±€ç‰¹å¾ï¼ˆå¯ç‚¹å‡»å…ƒç´ æ•°é‡ï¼‰
        element_count = len(state.get("clickable_elements", []))

        # ç»„åˆç‰¹å¾
        fingerprint = f"{activity}|{'|'.join(elements)}|{element_count}"

        # è®¡ç®—å“ˆå¸Œ
        import hashlib
        return hashlib.md5(fingerprint.encode()).hexdigest()

    @staticmethod
    def is_similar(fp1: str, fp2: str, threshold: float = 0.8) -> bool:
        """åˆ¤æ–­ä¸¤ä¸ªæŒ‡çº¹æ˜¯å¦ç›¸ä¼¼ï¼ˆç®€åŒ–ç‰ˆï¼Œå®é™…å¯ç”¨ç¼–è¾‘è·ç¦»ï¼‰"""
        return fp1 == fp2
```

### 5.2 å¯¼èˆªç¼“å­˜ï¼ˆåŠ é€Ÿè¿”å›ï¼‰

```python
class NavigationCache:
    """å¯¼èˆªè·¯å¾„ç¼“å­˜"""

    def __init__(self):
        self.cache = {}  # {(from_fingerprint, to_anchor): [actions]}

    def get_path(self, from_fp: str, to_anchor: str) -> list:
        """è·å–ç¼“å­˜çš„å¯¼èˆªè·¯å¾„"""
        return self.cache.get((from_fp, to_anchor))

    def set_path(self, from_fp: str, to_anchor: str, actions: list):
        """ç¼“å­˜å¯¼èˆªè·¯å¾„"""
        self.cache[(from_fp, to_anchor)] = actions

    def try_cached_navigation(self, from_state: dict, to_anchor: NavigationAnchor, adb_tools) -> bool:
        """å°è¯•ä½¿ç”¨ç¼“å­˜è·¯å¾„å¯¼èˆª"""
        from_fp = PageFingerprint.generate(from_state)
        cached_path = self.get_path(from_fp, to_anchor.anchor_page)

        if not cached_path:
            return False

        print("ğŸ’¡ ä½¿ç”¨ç¼“å­˜è·¯å¾„å¯¼èˆª...")
        try:
            for action in cached_path:
                if action["type"] == "back":
                    adb_tools.press_back()
                elif action["type"] == "click":
                    adb_tools.click(x=action["x"], y=action["y"])
                time.sleep(0.5)
            return True
        except:
            return False
```

### 5.3 æ™ºèƒ½æ·±åº¦æ§åˆ¶ï¼ˆé˜²æ­¢è¿·å¤±ï¼‰

```python
class DepthController:
    """é¡µé¢æ·±åº¦æ§åˆ¶å™¨ï¼Œé˜²æ­¢ä»»åŠ¡é™·å…¥è¿‡æ·±"""

    def __init__(self, max_depth: int = 5, warning_depth: int = 3):
        self.max_depth = max_depth
        self.warning_depth = warning_depth
        self.current_depth = 0

    def check_depth(self, page_tracker: PageStackTracker) -> dict:
        """
        æ£€æŸ¥é¡µé¢æ·±åº¦ï¼Œè¿”å›å»ºè®®

        Returns:
            {
                "status": "ok|warning|critical",
                "depth": 3,
                "suggestion": "å»ºè®®è¿”å›ä¸Šä¸€å±‚"
            }
        """
        depth = page_tracker.get_current_depth()

        if depth >= self.max_depth:
            return {
                "status": "critical",
                "depth": depth,
                "suggestion": "å¼ºåˆ¶è¿”å›ï¼Œæ·±åº¦è¿‡å¤§"
            }
        elif depth >= self.warning_depth:
            return {
                "status": "warning",
                "depth": depth,
                "suggestion": "å»ºè®®è€ƒè™‘è¿”å›ä¸Šå±‚"
            }
        else:
            return {
                "status": "ok",
                "depth": depth,
                "suggestion": ""
            }
```

---

## å…­ã€è°ƒè¯•å·¥å…·

### 6.1 å¯¼èˆªè·¯å¾„å¯è§†åŒ–

```python
def visualize_navigation_path(page_tracker: PageStackTracker):
    """å¯è§†åŒ–å¯¼èˆªè·¯å¾„"""
    print("\nğŸ“Š å½“å‰å¯¼èˆªè·¯å¾„:")
    print("=" * 80)

    for i, page in enumerate(page_tracker.page_stack):
        indent = "  " * i
        print(f"{indent}â””â”€ [{i}] {page['activity']}")
        print(f"{indent}   æ ‡é¢˜: {page.get('title', 'N/A')}")
        print(f"{indent}   å…³é”®å…ƒç´ : {', '.join(page.get('key_elements', [])[:3])}")
        print()

    print(f"æ€»æ·±åº¦: {len(page_tracker.page_stack)}")
    print("=" * 80)
```

### 6.2 é”šç‚¹éªŒè¯æµ‹è¯•

```python
def test_anchor_verification(adb_tools, anchor: NavigationAnchor):
    """æµ‹è¯•é”šç‚¹éªŒè¯è§„åˆ™æ˜¯å¦æ­£ç¡®"""
    print(f"ğŸ§ª æµ‹è¯•é”šç‚¹: {anchor.anchor_page}")

    state = adb_tools.get_state()
    compressed_state = StateCompressor.compress(state)

    is_match = anchor.is_at_anchor(compressed_state)

    print(f"å½“å‰é¡µé¢: {compressed_state.get('current_activity')}")
    print(f"éªŒè¯è§„åˆ™: {json.dumps(anchor.verification_rules, ensure_ascii=False, indent=2)}")
    print(f"åŒ¹é…ç»“æœ: {'âœ… åŒ¹é…' if is_match else 'âŒ ä¸åŒ¹é…'}")

    return is_match
```

---

## ä¸ƒã€å®Œæ•´ç¤ºä¾‹

```python
# å®Œæ•´ä½¿ç”¨æµç¨‹
def main():
    # 1. åˆå§‹åŒ–
    adb = AdbTools(use_tcp=True)
    llm = load_llm(...)
    controller = NavigationAwareController(adb, llm)

    # 2. å®šä¹‰é”šç‚¹
    taobao_search = CommonAnchors.TAOBAO_SEARCH

    # 3. æ‰§è¡Œä»»åŠ¡åºåˆ—
    tasks = [
        "æœç´¢'è“ç‰™è€³æœº'ï¼ŒæŸ¥çœ‹å‰3ä¸ªå•†å“",
        "æœç´¢'æ‰‹æœºå£³'ï¼ŒæŸ¥çœ‹é”€é‡æœ€é«˜çš„",
        "æœç´¢'æ•°æ®çº¿'ï¼Œç­›é€‰ä»·æ ¼20å…ƒä»¥ä¸‹çš„",
    ]

    for i, task in enumerate(tasks, 1):
        print(f"\n{'='*60}")
        print(f"ä»»åŠ¡ {i}/{len(tasks)}: {task}")
        print(f"{'='*60}")

        success = controller.run_task(task, anchor=taobao_search)

        if not success:
            print(f"âŒ ä»»åŠ¡ {i} å¤±è´¥")
            break

        print(f"âœ… ä»»åŠ¡ {i} å®Œæˆ")

        # å¯è§†åŒ–å¯¼èˆªè·¯å¾„
        visualize_navigation_path(controller.page_tracker)

    # 4. æœ€åè¿”å›æ¡Œé¢
    print("\nğŸ  è¿”å›æ¡Œé¢")
    adb.press_home()

if __name__ == "__main__":
    main()
```

---

## å…«ã€æ€»ç»“

### æ ¸å¿ƒç»„ä»¶
1. **NavigationAnchor**: å®šä¹‰ä»»åŠ¡èµ·å§‹é¡µé¢
2. **PageStackTracker**: è¿½è¸ªé¡µé¢å¯¼èˆªè·¯å¾„
3. **SmartBackNavigator**: æ™ºèƒ½è¿”å›åˆ°é”šç‚¹
4. **PageVerifier**: éªŒè¯æ˜¯å¦åˆ°è¾¾ç›®æ ‡é¡µé¢

### å¯¼èˆªç­–ç•¥ï¼ˆä¼˜å…ˆçº§é€’å‡ï¼‰
1. âœ… æ£€æŸ¥æ˜¯å¦å·²åœ¨é”šç‚¹
2. âœ… ä½¿ç”¨è¿”å›é”®ï¼ˆåŸºäºé¡µé¢æ ˆæ·±åº¦ï¼‰
3. âœ… ç‚¹å‡»"é¦–é¡µ"/"è¿”å›"æŒ‰é’®
4. âœ… é‡å¯åº”ç”¨åˆ°é¦–é¡µ
5. âš ï¸ LLM è¾…åŠ©å¯¼èˆªï¼ˆæœ€åæ‰‹æ®µï¼‰

### æœ€ä½³å®è·µ
- æ¯ä¸ªä»»åŠ¡å¼€å§‹å‰å…ˆå®šä¹‰é”šç‚¹
- ä»»åŠ¡å®Œæˆåè‡ªåŠ¨è¿”å›é”šç‚¹ï¼ˆå¯é€‰ï¼‰
- ä½¿ç”¨é¡µé¢æŒ‡çº¹å¿«é€Ÿè¯†åˆ«é¡µé¢
- é™åˆ¶é¡µé¢æ·±åº¦ï¼ˆå»ºè®® â‰¤ 5å±‚ï¼‰
- ç¼“å­˜å¸¸ç”¨å¯¼èˆªè·¯å¾„

### ä¸‹ä¸€æ­¥
1. å®ç° `PageStackTracker` å’Œ `SmartBackNavigator`
2. å®šä¹‰å¸¸ç”¨åº”ç”¨çš„é”šç‚¹è§„åˆ™
3. æµ‹è¯•å¯¼èˆªå‡†ç¡®æ€§å’Œé²æ£’æ€§
4. æ·»åŠ å¯¼èˆªè·¯å¾„ç¼“å­˜ä¼˜åŒ–

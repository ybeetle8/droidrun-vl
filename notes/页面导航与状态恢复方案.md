# 页面导航与状态恢复方案

## 一、问题分析

### 1.1 核心挑战
1. **深层页面嵌套**：任务执行可能进入多层子页面（如：首页 → 分类 → 商品详情 → 评论 → 图片查看）
2. **任务完成后迷失**：不知道当前在哪，也不知道如何回到起点
3. **下次任务起点不明确**：下一个任务应该从哪个页面开始？
4. **页面识别困难**：如何判断"已经到达目标页面"？

### 1.2 典型场景
```
场景1: 连续任务
- 任务1: 在淘宝搜索"手机" → 进入了商品详情页
- 任务2: 搜索"耳机" → 需要先回到首页或搜索页

场景2: 任务中断
- 任务: 浏览商品 → 点了好几层 → 想放弃任务回到首页

场景3: 应用切换
- 任务1: 在淘宝搜索商品
- 任务2: 在京东搜索商品 → 需要先退出淘宝，打开京东
```

---

## 二、解决方案设计

### 2.1 核心思路：导航锚点（Navigation Anchor）

**定义导航锚点**：每个任务开始前，定义一个"起始页面"作为锚点。

```python
class NavigationAnchor:
    """导航锚点，定义任务的起始页面"""

    def __init__(self,
                 app_package: str,           # 应用包名
                 anchor_page: str,           # 锚点页面标识
                 verification_rules: dict):   # 页面验证规则
        self.app_package = app_package
        self.anchor_page = anchor_page
        self.verification_rules = verification_rules

    def is_at_anchor(self, state: dict) -> bool:
        """判断当前是否在锚点页面"""
        pass

# 示例：淘宝搜索页作为锚点
taobao_search_anchor = NavigationAnchor(
    app_package="com.taobao.taobao",
    anchor_page="search_home",
    verification_rules={
        "activity_contains": "SearchActivity",
        "elements_contains": ["搜索框", "扫一扫", "拍照购"],
        "title_regex": r"搜索|淘宝"
    }
)
```

### 2.2 页面栈追踪（Page Stack Tracking）

**记录页面导航路径**，像浏览器的前进/后退按钮。

```python
class PageStackTracker:
    """页面栈追踪器"""

    def __init__(self):
        self.page_stack = []  # 页面栈
        self.max_depth = 10   # 最大追踪深度

    def push_page(self, page_info: dict):
        """进入新页面时记录"""
        page_snapshot = {
            "activity": page_info.get("current_activity"),
            "title": self._extract_title(page_info),
            "key_elements": self._extract_key_elements(page_info),
            "timestamp": time.time(),
            "depth": len(self.page_stack)
        }

        # 检测是否真的进入了新页面（避免重复记录）
        if not self.page_stack or not self._is_same_page(self.page_stack[-1], page_snapshot):
            self.page_stack.append(page_snapshot)

            # 限制栈深度
            if len(self.page_stack) > self.max_depth:
                self.page_stack.pop(0)

    def pop_page(self):
        """返回上一页时弹出"""
        if self.page_stack:
            return self.page_stack.pop()
        return None

    def get_current_depth(self) -> int:
        """获取当前页面深度"""
        return len(self.page_stack)

    def _is_same_page(self, page1: dict, page2: dict) -> bool:
        """判断是否是同一个页面"""
        # 比较 activity 和关键元素
        return (page1["activity"] == page2["activity"] and
                set(page1["key_elements"]) == set(page2["key_elements"]))

    def _extract_title(self, state: dict) -> str:
        """提取页面标题"""
        # 从UI状态中找标题栏文本
        for elem in state.get("clickable_elements", []):
            if "title" in elem.get("type", "").lower():
                return elem.get("text", "")
        return ""

    def _extract_key_elements(self, state: dict) -> list:
        """提取页面关键元素（用于识别页面）"""
        # 提取前5个可点击元素的文本作为页面特征
        elements = []
        for elem in state.get("clickable_elements", [])[:5]:
            text = elem.get("text", "").strip()
            if text:
                elements.append(text)
        return elements
```

### 2.3 智能返回导航器（Smart Back Navigator）

**核心组件**：负责将页面导航回锚点。

```python
class SmartBackNavigator:
    """智能返回导航器"""

    def __init__(self, adb_tools, llm=None):
        self.adb = adb_tools
        self.llm = llm  # 可选：用于复杂导航决策
        self.page_tracker = PageStackTracker()

    def navigate_to_anchor(self, anchor: NavigationAnchor, max_attempts: int = 10) -> bool:
        """
        导航回锚点页面

        策略优先级：
        1. 检查是否已在锚点 → 直接返回
        2. 尝试按返回键（基于页面栈深度）
        3. 尝试点击"首页"、"返回"按钮
        4. 重启应用到首页
        5. 如果锚点不是首页，使用LLM引导

        Returns:
            bool: 是否成功到达锚点
        """
        print(f"🎯 开始导航到锚点: {anchor.anchor_page}")

        for attempt in range(max_attempts):
            # 获取当前状态
            state = self.adb.get_state()
            compressed_state = StateCompressor.compress(state)

            # 策略1: 检查是否已在锚点
            if anchor.is_at_anchor(compressed_state):
                print(f"✅ 已到达锚点页面")
                return True

            print(f"📍 尝试 {attempt + 1}/{max_attempts}: 当前页面深度 {self.page_tracker.get_current_depth()}")

            # 策略2: 使用返回键（基于页面栈）
            if self.page_tracker.get_current_depth() > 0:
                success = self._try_back_button(compressed_state)
                if success:
                    self.page_tracker.pop_page()
                    time.sleep(1)
                    continue

            # 策略3: 尝试点击导航按钮
            success = self._try_navigation_buttons(compressed_state, anchor)
            if success:
                time.sleep(1)
                continue

            # 策略4: 重启应用
            if attempt >= max_attempts // 2:
                print("⚠️ 尝试重启应用...")
                self._restart_app(anchor.app_package)
                time.sleep(2)
                continue

            # 策略5: LLM辅助导航（最后手段）
            if self.llm and attempt >= max_attempts - 2:
                success = self._llm_guided_navigation(compressed_state, anchor)
                if success:
                    time.sleep(1)
                    continue

            # 都失败了，等待一下重试
            time.sleep(1)

        print(f"❌ 无法导航到锚点")
        return False

    def _try_back_button(self, state: dict) -> bool:
        """尝试使用返回键"""
        try:
            print("  → 尝试返回键")
            self.adb.press_back()
            return True
        except:
            return False

    def _try_navigation_buttons(self, state: dict, anchor: NavigationAnchor) -> bool:
        """尝试点击导航按钮（首页、返回等）"""
        # 定义导航关键词
        nav_keywords = ["首页", "主页", "返回", "home", "back", "取消", "关闭"]

        for elem in state.get("clickable_elements", []):
            text = elem.get("text", "").lower()
            desc = elem.get("content_desc", "").lower()

            # 检查是否是导航按钮
            for keyword in nav_keywords:
                if keyword in text or keyword in desc:
                    try:
                        print(f"  → 尝试点击导航按钮: {elem.get('text', elem.get('content_desc'))}")
                        self.adb.click(index=elem["index"])
                        return True
                    except:
                        pass

        return False

    def _restart_app(self, package: str):
        """重启应用"""
        try:
            # 强制停止
            self.adb.device.app_stop(package)
            time.sleep(1)
            # 重新启动
            self.adb.device.app_start(package)
            # 清空页面栈
            self.page_tracker.page_stack.clear()
        except Exception as e:
            print(f"⚠️ 重启应用失败: {e}")

    def _llm_guided_navigation(self, state: dict, anchor: NavigationAnchor) -> bool:
        """使用LLM引导导航（最后手段）"""
        if not self.llm:
            return False

        prompt = f"""当前页面状态：
{json.dumps(state, ensure_ascii=False, indent=2)}

目标：导航到 {anchor.anchor_page} 页面

请判断应该执行什么操作才能更接近目标页面。返回JSON格式：
{{
    "action": "click|back|home",
    "params": {{"index": 0}} 或 {{}}
}}
"""

        try:
            response = self.llm.chat(prompt)
            action = json.loads(response)

            if action["action"] == "click":
                self.adb.click(index=action["params"]["index"])
                return True
            elif action["action"] == "back":
                self.adb.press_back()
                return True
            elif action["action"] == "home":
                self.adb.press_home()
                time.sleep(1)
                self.adb.device.app_start(anchor.app_package)
                return True
        except:
            pass

        return False
```

### 2.4 页面验证器（Page Verifier）

**用于判断"是否到达目标页面"**。

```python
class PageVerifier:
    """页面验证器"""

    @staticmethod
    def verify_page(state: dict, verification_rules: dict) -> bool:
        """
        根据规则验证页面

        支持的验证规则：
        - activity_contains: Activity名称包含关键词
        - activity_equals: Activity名称完全匹配
        - elements_contains: 页面包含特定文本元素（AND关系）
        - elements_any: 页面包含任一文本元素（OR关系）
        - title_regex: 标题匹配正则表达式
        - package_equals: 包名完全匹配
        """
        # 提取当前页面信息
        current_activity = state.get("current_activity", "")
        current_package = state.get("package", "")
        elements_texts = [
            elem.get("text", "").lower()
            for elem in state.get("clickable_elements", [])
        ]

        # 验证 activity
        if "activity_contains" in verification_rules:
            keyword = verification_rules["activity_contains"].lower()
            if keyword not in current_activity.lower():
                return False

        if "activity_equals" in verification_rules:
            if current_activity != verification_rules["activity_equals"]:
                return False

        # 验证包名
        if "package_equals" in verification_rules:
            if current_package != verification_rules["package_equals"]:
                return False

        # 验证元素存在（AND）
        if "elements_contains" in verification_rules:
            required = [kw.lower() for kw in verification_rules["elements_contains"]]
            for kw in required:
                if not any(kw in text for text in elements_texts):
                    return False

        # 验证元素存在（OR）
        if "elements_any" in verification_rules:
            keywords = [kw.lower() for kw in verification_rules["elements_any"]]
            if not any(any(kw in text for text in elements_texts) for kw in keywords):
                return False

        # 验证标题正则
        if "title_regex" in verification_rules:
            import re
            title = PageVerifier._extract_title(state)
            if not re.search(verification_rules["title_regex"], title):
                return False

        return True

    @staticmethod
    def _extract_title(state: dict) -> str:
        """提取页面标题"""
        # 优先查找顶部的文本元素
        for elem in state.get("clickable_elements", [])[:5]:
            if elem.get("bounds", [0, 0, 0, 0])[1] < 200:  # 顶部区域
                text = elem.get("text", "").strip()
                if text:
                    return text
        return ""
```

---

## 三、集成到控制器

### 3.1 增强的控制器

```python
class NavigationAwareController:
    """支持导航的手机控制器"""

    def __init__(self, adb_tools, llm, max_steps=20):
        self.adb = adb_tools
        self.llm = llm
        self.max_steps = max_steps

        # 导航组件
        self.navigator = SmartBackNavigator(adb_tools, llm)
        self.page_tracker = self.navigator.page_tracker

        # 任务历史
        self.history = []
        self.step_count = 0

    def run_task(self, goal: str, anchor: NavigationAnchor = None):
        """
        执行任务（带导航支持）

        Args:
            goal: 任务目标
            anchor: 任务起始页面锚点（如果为None，则从当前页面开始）
        """
        print(f"🎯 任务: {goal}")

        # 1. 导航到起始页面
        if anchor:
            success = self.navigator.navigate_to_anchor(anchor)
            if not success:
                print("❌ 无法导航到起始页面，任务终止")
                return False
            # 重置页面栈
            self.page_tracker.page_stack.clear()

        # 2. 执行任务主循环
        task_result = self._execute_task_loop(goal)

        # 3. 任务完成后，返回到锚点（可选）
        if anchor and task_result:
            print("\n📍 任务完成，准备返回起始页面...")
            self.navigator.navigate_to_anchor(anchor)

        return task_result

    def _execute_task_loop(self, goal: str) -> bool:
        """任务执行主循环"""
        while self.step_count < self.max_steps:
            # 获取状态
            state = self.adb.get_state()
            compressed_state = StateCompressor.compress(state)

            # 追踪页面
            self.page_tracker.push_page(compressed_state)

            # 决策动作
            action = self.decide_action(goal, compressed_state)

            # 执行动作
            result = self.execute_action(action)

            # 记录历史
            self.history.append((compressed_state, action, result))
            self.step_count += 1

            print(f"步骤 {self.step_count}: {action['action']} (深度: {self.page_tracker.get_current_depth()})")

            # 检查终止
            if action['action'] == 'finish':
                print("✅ 任务完成")
                return True

            if self.should_stop(action, result):
                print("⚠️ 任务中止")
                return False

            time.sleep(1)

        print("⚠️ 达到最大步数")
        return False

    def decide_action(self, goal: str, state: dict) -> dict:
        """决策动作（省略，参考之前的方案）"""
        pass

    def execute_action(self, action: dict) -> dict:
        """执行动作（省略，参考之前的方案）"""
        pass

    def should_stop(self, action: dict, result: dict) -> bool:
        """判断是否停止（省略，参考之前的方案）"""
        pass
```

### 3.2 预定义常用锚点

```python
class CommonAnchors:
    """常用应用的锚点定义"""

    # 淘宝搜索页
    TAOBAO_SEARCH = NavigationAnchor(
        app_package="com.taobao.taobao",
        anchor_page="search_home",
        verification_rules={
            "package_equals": "com.taobao.taobao",
            "elements_contains": ["搜索框", "扫一扫"],
        }
    )

    # 淘宝首页
    TAOBAO_HOME = NavigationAnchor(
        app_package="com.taobao.taobao",
        anchor_page="main_home",
        verification_rules={
            "package_equals": "com.taobao.taobao",
            "elements_any": ["首页", "主页", "淘宝"],
        }
    )

    # 京东搜索页
    JD_SEARCH = NavigationAnchor(
        app_package="com.jingdong.app.mall",
        anchor_page="search_home",
        verification_rules={
            "package_equals": "com.jingdong.app.mall",
            "elements_contains": ["搜索"],
        }
    )

    # 微信聊天列表
    WECHAT_CHAT_LIST = NavigationAnchor(
        app_package="com.tencent.mm",
        anchor_page="chat_list",
        verification_rules={
            "package_equals": "com.tencent.mm",
            "elements_contains": ["微信", "通讯录"],
        }
    )

    @staticmethod
    def get_anchor(app_name: str, page_name: str = "home") -> NavigationAnchor:
        """根据应用名获取锚点"""
        anchors = {
            "taobao": {
                "home": CommonAnchors.TAOBAO_HOME,
                "search": CommonAnchors.TAOBAO_SEARCH,
            },
            "jd": {
                "search": CommonAnchors.JD_SEARCH,
            },
            "wechat": {
                "chat_list": CommonAnchors.WECHAT_CHAT_LIST,
            }
        }

        return anchors.get(app_name, {}).get(page_name)
```

---

## 四、使用示例

### 4.1 基础使用

```python
# 初始化
adb = AdbTools(use_tcp=True)
llm = load_llm(provider_name="OpenAILike", model="/models", ...)
controller = NavigationAwareController(adb, llm)

# 场景1: 单个任务（自动返回起点）
anchor = CommonAnchors.TAOBAO_SEARCH
controller.run_task("搜索'手机'，点击第一个商品查看详情", anchor=anchor)
# 任务完成后会自动返回搜索页

# 场景2: 连续任务
controller.run_task("搜索'手机'", anchor=anchor)
controller.run_task("搜索'耳机'", anchor=anchor)  # 会先返回搜索页再执行

# 场景3: 不指定锚点（从当前页面开始）
controller.run_task("点击第一个商品")  # 从当前页面开始，完成后停留在结果页
```

### 4.2 多应用切换

```python
class MultiAppController:
    """多应用任务控制器"""

    def __init__(self, adb_tools, llm):
        self.controller = NavigationAwareController(adb_tools, llm)

    def run_multi_app_tasks(self, tasks: list):
        """
        执行跨应用任务列表

        Args:
            tasks: [
                {"app": "taobao", "goal": "搜索手机", "anchor": "search"},
                {"app": "jd", "goal": "搜索耳机", "anchor": "search"},
            ]
        """
        for task in tasks:
            app_name = task["app"]
            goal = task["goal"]
            anchor_name = task.get("anchor", "home")

            # 获取锚点
            anchor = CommonAnchors.get_anchor(app_name, anchor_name)

            if not anchor:
                print(f"⚠️ 未找到应用 {app_name} 的锚点 {anchor_name}")
                continue

            print(f"\n{'='*60}")
            print(f"🚀 切换到 {app_name} 执行任务: {goal}")
            print(f"{'='*60}")

            # 执行任务
            success = self.controller.run_task(goal, anchor=anchor)

            if not success:
                print(f"❌ 任务失败: {goal}")
            else:
                print(f"✅ 任务完成: {goal}")

# 使用
multi_controller = MultiAppController(adb, llm)
multi_controller.run_multi_app_tasks([
    {"app": "taobao", "goal": "搜索'手机'，查看前3个商品价格", "anchor": "search"},
    {"app": "jd", "goal": "搜索'手机'，查看前3个商品价格", "anchor": "search"},
    {"app": "taobao", "goal": "对比价格，选择最便宜的", "anchor": "search"},
])
```

### 4.3 紧急返回功能

```python
def emergency_return_home(adb_tools):
    """紧急返回桌面（任务失控时使用）"""
    print("🚨 紧急返回桌面...")
    adb_tools.press_home()
    time.sleep(1)

def emergency_return_app_home(adb_tools, package: str):
    """紧急返回应用首页"""
    print(f"🚨 紧急返回 {package} 首页...")
    # 方法1: 多次返回键
    for _ in range(5):
        adb_tools.press_back()
        time.sleep(0.5)

    # 方法2: 重启应用
    adb_tools.device.app_stop(package)
    time.sleep(1)
    adb_tools.device.app_start(package)
```

---

## 五、高级优化

### 5.1 页面指纹识别（快速判断页面）

```python
class PageFingerprint:
    """页面指纹，用于快速识别页面"""

    @staticmethod
    def generate(state: dict) -> str:
        """生成页面指纹"""
        # 特征1: Activity
        activity = state.get("current_activity", "")

        # 特征2: 关键元素文本（前5个）
        elements = []
        for elem in state.get("clickable_elements", [])[:5]:
            text = elem.get("text", "").strip()
            if text:
                elements.append(text)

        # 特征3: 布局特征（可点击元素数量）
        element_count = len(state.get("clickable_elements", []))

        # 组合特征
        fingerprint = f"{activity}|{'|'.join(elements)}|{element_count}"

        # 计算哈希
        import hashlib
        return hashlib.md5(fingerprint.encode()).hexdigest()

    @staticmethod
    def is_similar(fp1: str, fp2: str, threshold: float = 0.8) -> bool:
        """判断两个指纹是否相似（简化版，实际可用编辑距离）"""
        return fp1 == fp2
```

### 5.2 导航缓存（加速返回）

```python
class NavigationCache:
    """导航路径缓存"""

    def __init__(self):
        self.cache = {}  # {(from_fingerprint, to_anchor): [actions]}

    def get_path(self, from_fp: str, to_anchor: str) -> list:
        """获取缓存的导航路径"""
        return self.cache.get((from_fp, to_anchor))

    def set_path(self, from_fp: str, to_anchor: str, actions: list):
        """缓存导航路径"""
        self.cache[(from_fp, to_anchor)] = actions

    def try_cached_navigation(self, from_state: dict, to_anchor: NavigationAnchor, adb_tools) -> bool:
        """尝试使用缓存路径导航"""
        from_fp = PageFingerprint.generate(from_state)
        cached_path = self.get_path(from_fp, to_anchor.anchor_page)

        if not cached_path:
            return False

        print("💡 使用缓存路径导航...")
        try:
            for action in cached_path:
                if action["type"] == "back":
                    adb_tools.press_back()
                elif action["type"] == "click":
                    adb_tools.click(x=action["x"], y=action["y"])
                time.sleep(0.5)
            return True
        except:
            return False
```

### 5.3 智能深度控制（防止迷失）

```python
class DepthController:
    """页面深度控制器，防止任务陷入过深"""

    def __init__(self, max_depth: int = 5, warning_depth: int = 3):
        self.max_depth = max_depth
        self.warning_depth = warning_depth
        self.current_depth = 0

    def check_depth(self, page_tracker: PageStackTracker) -> dict:
        """
        检查页面深度，返回建议

        Returns:
            {
                "status": "ok|warning|critical",
                "depth": 3,
                "suggestion": "建议返回上一层"
            }
        """
        depth = page_tracker.get_current_depth()

        if depth >= self.max_depth:
            return {
                "status": "critical",
                "depth": depth,
                "suggestion": "强制返回，深度过大"
            }
        elif depth >= self.warning_depth:
            return {
                "status": "warning",
                "depth": depth,
                "suggestion": "建议考虑返回上层"
            }
        else:
            return {
                "status": "ok",
                "depth": depth,
                "suggestion": ""
            }
```

---

## 六、调试工具

### 6.1 导航路径可视化

```python
def visualize_navigation_path(page_tracker: PageStackTracker):
    """可视化导航路径"""
    print("\n📊 当前导航路径:")
    print("=" * 80)

    for i, page in enumerate(page_tracker.page_stack):
        indent = "  " * i
        print(f"{indent}└─ [{i}] {page['activity']}")
        print(f"{indent}   标题: {page.get('title', 'N/A')}")
        print(f"{indent}   关键元素: {', '.join(page.get('key_elements', [])[:3])}")
        print()

    print(f"总深度: {len(page_tracker.page_stack)}")
    print("=" * 80)
```

### 6.2 锚点验证测试

```python
def test_anchor_verification(adb_tools, anchor: NavigationAnchor):
    """测试锚点验证规则是否正确"""
    print(f"🧪 测试锚点: {anchor.anchor_page}")

    state = adb_tools.get_state()
    compressed_state = StateCompressor.compress(state)

    is_match = anchor.is_at_anchor(compressed_state)

    print(f"当前页面: {compressed_state.get('current_activity')}")
    print(f"验证规则: {json.dumps(anchor.verification_rules, ensure_ascii=False, indent=2)}")
    print(f"匹配结果: {'✅ 匹配' if is_match else '❌ 不匹配'}")

    return is_match
```

---

## 七、完整示例

```python
# 完整使用流程
def main():
    # 1. 初始化
    adb = AdbTools(use_tcp=True)
    llm = load_llm(...)
    controller = NavigationAwareController(adb, llm)

    # 2. 定义锚点
    taobao_search = CommonAnchors.TAOBAO_SEARCH

    # 3. 执行任务序列
    tasks = [
        "搜索'蓝牙耳机'，查看前3个商品",
        "搜索'手机壳'，查看销量最高的",
        "搜索'数据线'，筛选价格20元以下的",
    ]

    for i, task in enumerate(tasks, 1):
        print(f"\n{'='*60}")
        print(f"任务 {i}/{len(tasks)}: {task}")
        print(f"{'='*60}")

        success = controller.run_task(task, anchor=taobao_search)

        if not success:
            print(f"❌ 任务 {i} 失败")
            break

        print(f"✅ 任务 {i} 完成")

        # 可视化导航路径
        visualize_navigation_path(controller.page_tracker)

    # 4. 最后返回桌面
    print("\n🏠 返回桌面")
    adb.press_home()

if __name__ == "__main__":
    main()
```

---

## 八、总结

### 核心组件
1. **NavigationAnchor**: 定义任务起始页面
2. **PageStackTracker**: 追踪页面导航路径
3. **SmartBackNavigator**: 智能返回到锚点
4. **PageVerifier**: 验证是否到达目标页面

### 导航策略（优先级递减）
1. ✅ 检查是否已在锚点
2. ✅ 使用返回键（基于页面栈深度）
3. ✅ 点击"首页"/"返回"按钮
4. ✅ 重启应用到首页
5. ⚠️ LLM 辅助导航（最后手段）

### 最佳实践
- 每个任务开始前先定义锚点
- 任务完成后自动返回锚点（可选）
- 使用页面指纹快速识别页面
- 限制页面深度（建议 ≤ 5层）
- 缓存常用导航路径

### 下一步
1. 实现 `PageStackTracker` 和 `SmartBackNavigator`
2. 定义常用应用的锚点规则
3. 测试导航准确性和鲁棒性
4. 添加导航路径缓存优化

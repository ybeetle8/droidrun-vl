# 图片与指令提交方式对比分析

## 概述

本文档详细对比了 **test_screen_analysis.py** 测试脚本与 **DroidRun 框架**中图片和指令提交到 LLM 的实现方式，帮助理解两者的设计差异和优劣。

---

## 一、test_screen_analysis.py 的实现方式

### 1.1 核心流程

test_screen_analysis.py 是一个**直接、简单的单次分析脚本**，流程如下：

```
获取截图和UI状态 → 构建提示词 → 创建消息块 → 调用LLM → 流式输出结果 → 保存到文件
```

### 1.2 图片提交方式

**文件位置**：test/test_screen_analysis.py:46-117

**实现细节**：

```python
# 1. 获取截图（字节数据）
_, screenshot_bytes = adb_tools.take_screenshot(hide_overlay=True)

# 2. 构建提示词（包含 UI 状态 JSON）
prompt = f"""请分析这个Android屏幕截图和UI状态信息...
下面是UI状态的JSON数据：
```json
{state_json_str}
```"""

# 3. 创建消息块（文本 + 图片）
content_blocks = [
    TextBlock(text=prompt),
    ImageBlock(image=screenshot_bytes)  # 直接使用字节数据
]

# 4. 构建聊天消息
message = ChatMessage(
    role=MessageRole.USER,
    content=content_blocks,
)

# 5. 流式调用 LLM
response_stream = llm.stream_chat([message], **extra_params)
```

**特点**：
- ✅ **简单直接**：一次性构建消息，单轮对话
- ✅ **明确的提示词**：详细的分析要求，包含 JSON 格式的 UI 状态
- ✅ **流式输出**：使用 `stream_chat` 实时显示分析结果
- ✅ **完整保存**：截图、UI状态、分析结果全部保存到文件
- ⚠️ **无上下文管理**：没有历史消息管理
- ⚠️ **单次执行**：不支持多轮对话或迭代执行

### 1.3 指令提交方式

**提示词结构**：
- 明确的分析任务（搜索框位置、商品信息）
- 输出格式要求（中文、详细、避免重复）
- UI 状态数据以 JSON 格式嵌入

**参数控制**：
```python
llm = load_llm(
    provider_name="OpenAILike",
    model=MODEL,
    api_base=API_BASE,
    temperature=0.0,
    request_timeout=60.0,
    max_tokens=4048,  # 限制输出长度
)

# 防止无限循环的额外参数
VLLM_EXTRA_PARAMS = {
    "frequency_penalty": 0.05,  # 减少重复
    "presence_penalty": 0.05,   # 鼓励多样性
}
```

---

## 二、DroidRun 框架的实现方式

### 2.1 核心流程

DroidRun 使用**基于 Workflow 的 ReAct 循环**，是一个复杂的多步骤执行框架：

```
准备聊天 → 处理LLM输入 → LLM思考 → 提取代码 → 执行代码 → 处理结果 → 循环（最多max_steps次）
```

### 2.2 图片提交方式

**文件位置**：droidrun/agent/codeact/codeact_agent.py:170-182

**实现细节**：

```python
# 1. 在 handle_llm_input 步骤中动态添加截图
for context in self.required_context:
    if context == "screenshot":
        # 获取截图
        screenshot = (self.tools.take_screenshot())[1]

        # 发送截图事件（用于轨迹记录）
        ctx.write_event_to_stream(ScreenshotEvent(screenshot=screenshot))

        # 保存到工作流上下文
        await ctx.store.set("screenshot", screenshot)

        # 如果启用视觉模式，添加图片块到聊天历史
        if self.vision == True:
            chat_history = await chat_utils.add_screenshot_image_block(
                screenshot, chat_history
            )
```

**文件位置**：droidrun/agent/utils/chat_utils.py:121-128

```python
async def add_screenshot_image_block(screenshot, chat_history, copy=True):
    if screenshot:
        image_block = ImageBlock(image=screenshot)

        if copy:
            # 创建副本避免修改原始历史
            chat_history = chat_history.copy()
            chat_history[-1] = message_copy(chat_history[-1])

        # 将图片块追加到最后一条消息
        chat_history[-1].blocks.append(image_block)

    return chat_history
```

**特点**：
- ✅ **动态注入**：根据 `required_context` 配置动态添加截图
- ✅ **条件启用**：通过 `--vision` 参数控制是否使用视觉能力
- ✅ **历史保留**：截图添加到聊天历史，支持多轮对话
- ✅ **上下文共享**：通过 Workflow Context 在步骤间共享截图
- ✅ **轨迹记录**：通过事件流记录所有截图到 EpisodicMemory
- ⚠️ **复杂度高**：需要理解 Workflow、Context、Events 等概念

### 2.3 指令提交方式

**文件位置**：droidrun/agent/codeact/codeact_agent.py:109-142

**提示词构建**：

```python
# 1. 准备初始用户消息
self.user_message = ChatMessage(
    role="user",
    content=PromptTemplate(DEFAULT_CODE_ACT_USER_PROMPT).format(goal=goal),
)

# 2. 添加到聊天记忆
await self.chat_memory.aput(self.user_message)
```

**文件位置**：droidrun/agent/codeact/prompts.py:10-13

```python
DEFAULT_CODE_ACT_USER_PROMPT = """**Current Request:**
{goal}

**Is the precondition met? What is your reasoning and the next step to address this request?**
Explain your thought process then provide code in ```python ... ``` tags if needed."""
```

**动态上下文注入**（文件位置：codeact_agent.py:170-201）：

```python
for context in self.required_context:
    if context == "screenshot":
        # 添加截图块（如前所述）

    if context == "ui_state":
        # 添加 UI 状态块
        state = self.tools.get_state()
        chat_history = await chat_utils.add_ui_text_block(
            state["a11y_tree"], chat_history
        )
        chat_history = await chat_utils.add_phone_state_block(
            state["phone_state"], chat_history
        )

    if context == "packages":
        # 添加已安装应用列表
        chat_history = await chat_utils.add_packages_block(
            self.tools.list_packages(include_system_apps=True),
            chat_history,
        )
```

**文件位置**：droidrun/agent/utils/chat_utils.py:103-119

```python
async def add_ui_text_block(ui_state, chat_history, copy=True):
    if ui_state:
        # 解析 JSON 并格式化为自然语言
        ui_data = json.loads(ui_state) if isinstance(ui_state, str) else ui_state
        formatted_ui = _format_ui_elements(ui_data)

        # 创建文本块（格式化为：index. className: resourceId, text - bounds）
        ui_block = TextBlock(
            text=f"\nCurrent Clickable UI elements from the device in the schema "
                 f"'index. className: resourceId, text - bounds(x1,y1,x2,y2)':\n{formatted_ui}\n"
        )

        if copy:
            chat_history = chat_history.copy()
            chat_history[-1] = message_copy(chat_history[-1])

        chat_history[-1].blocks.append(ui_block)

    return chat_history
```

**特点**：
- ✅ **ReAct 模式**：引导 LLM 先思考，再生成代码
- ✅ **上下文丰富**：动态注入截图、UI状态、应用列表等
- ✅ **格式化优化**：UI 状态从 JSON 转换为自然语言（更易于 LLM 理解）
- ✅ **记忆管理**：使用 `Memory` 类管理聊天历史
- ✅ **历史限制**：通过 `_limit_history` 防止上下文过长
- ✅ **工具注入**：系统提示中包含所有可用工具的描述

### 2.4 消息历史管理

**文件位置**：droidrun/agent/codeact/codeact_agent.py:430-448

```python
def _limit_history(self, chat_history: List[ChatMessage]) -> List[ChatMessage]:
    """限制聊天历史长度，防止上下文溢出"""
    if LLM_HISTORY_LIMIT <= 0:
        return chat_history

    max_messages = LLM_HISTORY_LIMIT * 2
    if len(chat_history) <= max_messages:
        return chat_history

    # 保留第一条消息（通常是任务描述）
    preserved_head = []
    if chat_history and chat_history[0].role == "user":
        preserved_head = [chat_history[0]]

    # 保留最近的消息
    tail = chat_history[-max_messages:]
    if preserved_head and preserved_head[0] in tail:
        preserved_head = []

    return preserved_head + tail
```

**文件位置**：droidrun/agent/codeact/codeact_agent.py:348-428

```python
async def _get_llm_response(self, ctx: Context, chat_history: List[ChatMessage]):
    # 1. 限制历史长度
    limited_history = self._limit_history(chat_history)

    # 2. 添加系统提示
    messages_to_send = [self.system_prompt] + limited_history

    # 3. 消息深拷贝（避免修改原始消息）
    messages_to_send = [chat_utils.message_copy(msg) for msg in messages_to_send]

    # 4. 调用 LLM
    response = await self.llm.achat(messages=messages_to_send)

    # 5. 过滤图片块（用于保存到 EpisodicMemory）
    filtered_chat_history = []
    for msg in limited_history:
        filtered_msg = chat_utils.message_copy(msg)
        if hasattr(filtered_msg, "blocks") and filtered_msg.blocks:
            filtered_msg.blocks = [
                block for block in filtered_msg.blocks
                if not isinstance(block, chat_utils.ImageBlock)
            ]
        filtered_chat_history.append(filtered_msg)

    # 6. 保存到 Episodic Memory
    step = EpisodicMemoryStep(
        chat_history=json.dumps([{"role": msg.role, "content": msg.content}
                                 for msg in filtered_chat_history]),
        response=json.dumps({"role": response.message.role,
                            "content": response.message.content}),
        timestamp=time.time(),
        screenshot=(await ctx.store.get("screenshot", None))
    )
    self.episodic_memory.steps.append(step)

    return response
```

---

## 三、关键差异对比

| 对比维度 | test_screen_analysis.py | DroidRun 框架 |
|---------|------------------------|--------------|
| **架构模式** | 单次脚本执行 | Workflow + ReAct 循环 |
| **图片提交** | 直接创建 ImageBlock | 动态注入到聊天历史 |
| **UI 状态格式** | JSON 字符串嵌入提示词 | 格式化为自然语言文本块 |
| **提示词** | 详细的分析任务 | ReAct 风格（思考 → 代码） |
| **上下文管理** | 无 | Memory + 历史限制 |
| **多轮对话** | 不支持 | 支持（最多 max_steps 轮） |
| **代码执行** | 无 | 支持（通过 SimpleCodeExecutor） |
| **轨迹记录** | 保存到文件 | EpisodicMemory + 事件流 |
| **配置灵活性** | 硬编码参数 | Persona + required_context |
| **错误处理** | 基础异常捕获 | 重试机制 + 限流处理 |
| **视觉能力控制** | 默认启用 | `--vision` 参数控制 |
| **输出方式** | 流式打印 + 文件保存 | 事件流 + Rich 格式化 |

---

## 四、详细差异分析

### 4.1 消息块（Content Blocks）的使用

**test_screen_analysis.py**：
```python
# 一次性构建所有内容块
content_blocks = [
    TextBlock(text=prompt),      # 提示词（包含 UI JSON）
    ImageBlock(image=screenshot) # 截图
]
message = ChatMessage(role=MessageRole.USER, content=content_blocks)
```

**DroidRun**：
```python
# 逐步追加内容块到最后一条消息
chat_history[-1].blocks.append(TextBlock(text=ui_text))        # UI 状态
chat_history[-1].blocks.append(TextBlock(text=phone_state))    # 手机状态
chat_history[-1].blocks.append(ImageBlock(image=screenshot))   # 截图
```

**差异**：
- test_screen_analysis.py：**一次性构建**，适合单轮对话
- DroidRun：**动态追加**，支持多轮对话和上下文累积

### 4.2 UI 状态的表示方式

**test_screen_analysis.py**：
```python
# 直接嵌入 JSON 字符串
prompt = f"""...
下面是UI状态的JSON数据：
```json
{state_json_str}
```"""
```

**DroidRun**：
```python
# 格式化为自然语言（chat_utils.py:50-101）
def _format_ui_elements(ui_data, level=0) -> str:
    """
    格式：index. className: resourceId, text - bounds
    示例：
    0. TextView: "com.example:id/title", "Hello" - (100,200,500,300)
      1. Button: "com.example:id/btn", "Click" - (150,250,450,280)
    """
    # ... 递归格式化，支持缩进表示层级
```

**差异**：
- test_screen_analysis.py：**JSON 格式**，结构清晰但冗长
- DroidRun：**自然语言格式**，更简洁，更易于 LLM 理解

### 4.3 图片数据的来源

**test_screen_analysis.py**：
```python
# 每次从设备获取
_, screenshot_bytes = adb_tools.take_screenshot(hide_overlay=True)
```

**DroidRun**：
```python
# 1. 获取并保存到 Context
screenshot = (self.tools.take_screenshot())[1]
await ctx.store.set("screenshot", screenshot)

# 2. 后续步骤可复用
screenshot = await ctx.store.get("screenshot", None)
```

**差异**：
- test_screen_analysis.py：**一次性使用**
- DroidRun：**Context 共享**，可在多个步骤中复用（如保存到 EpisodicMemory）

### 4.4 LLM 调用方式

**test_screen_analysis.py**：
```python
# 流式调用，实时输出
response_stream = llm.stream_chat([message], **extra_params)
for chunk in response_stream:
    print(chunk.delta, end="", flush=True)
```

**DroidRun**：
```python
# 异步调用，等待完整响应
response = await self.llm.achat(messages=messages_to_send)

# 提取代码和思考
code, thoughts = chat_utils.extract_code_and_thought(response.message.content)

# 如果有代码，执行它
if code:
    result = await self.executor.execute(ctx, code)
```

**差异**：
- test_screen_analysis.py：**流式输出**，用户友好
- DroidRun：**完整响应 + 代码执行**，支持 ReAct 循环

### 4.5 系统提示的构建

**test_screen_analysis.py**：
```python
# 无系统提示，所有指令在用户消息中
```

**DroidRun**：
```python
# 系统提示包含工具描述（codeact_agent.py:89-94）
self.system_prompt_content = persona.system_prompt.format(
    tool_descriptions=self.tool_descriptions  # 所有可用工具的函数签名
)
self.system_prompt = ChatMessage(role="system", content=self.system_prompt_content)

# 发送时：[system_prompt] + [聊天历史]
messages_to_send = [self.system_prompt] + limited_history
```

**差异**：
- test_screen_analysis.py：**无系统提示**，适合简单分析任务
- DroidRun：**详细的系统提示**，包含所有工具描述和 ReAct 指导

---

## 五、适用场景对比

### test_screen_analysis.py 适合：
- ✅ **快速原型验证**：测试 LLM 的视觉分析能力
- ✅ **单次分析任务**：生成报告、提取信息
- ✅ **调试和实验**：调整提示词、参数
- ✅ **数据收集**：批量分析截图并保存结果

### DroidRun 框架适合：
- ✅ **复杂任务执行**：需要多步骤操作（打开应用、点击、输入）
- ✅ **智能代理**：自主决策和代码生成
- ✅ **长期运行**：多轮交互、错误恢复
- ✅ **可扩展性**：通过 Persona 和 Tools 定制行为

---

## 六、关键技术点总结

### 6.1 图片提交的核心原理

两者都使用 `llama_index` 的 `ImageBlock`：

```python
from llama_index.core.base.llms.types import ImageBlock

# 创建图片块（接受字节数据）
image_block = ImageBlock(image=screenshot_bytes)
```

**差异在于**：
1. **何时创建**：
   - test_screen_analysis.py：调用 LLM 前
   - DroidRun：每个 ReAct 步骤动态创建

2. **如何传递**：
   - test_screen_analysis.py：直接放入消息的 `content` 列表
   - DroidRun：追加到 `chat_history[-1].blocks`

3. **是否保留**：
   - test_screen_analysis.py：不保留历史
   - DroidRun：保留在 `Memory` 中（但发送到 EpisodicMemory 时会过滤）

### 6.2 UI 状态的处理差异

| 方面 | test_screen_analysis.py | DroidRun |
|-----|------------------------|----------|
| **数据来源** | `adb_tools.get_state()` | `self.tools.get_state()["a11y_tree"]` |
| **格式** | JSON 字符串 | 自然语言（格式化） |
| **嵌入方式** | f-string 嵌入提示词 | TextBlock 追加到消息块 |
| **示例** | `{"index": 0, "text": "Hello"}` | `0. TextView: "Hello" - (100,200,500,300)` |

### 6.3 提示词设计差异

**test_screen_analysis.py**（分析导向）：
```
请分析这个Android屏幕截图和UI状态信息，提供详细的分析报告。

1. **屏幕概览**
   - 搜索框的位置 index 和 x,y 坐标

2. **内容分析**
   - 商品详细信息，要列出来...
```

**DroidRun**（行动导向）：
```
**Current Request:**
打开淘宝并搜索 iPhone

**Is the precondition met? What is your reasoning and the next step?**
Explain your thought process then provide code in ```python ... ``` tags.
```

**差异**：
- test_screen_analysis.py：**描述型任务**（分析、总结）
- DroidRun：**执行型任务**（代码生成、操作设备）

---

## 七、实现建议

### 7.1 如果你想在 test_screen_analysis.py 中使用 DroidRun 的技术

1. **添加聊天历史管理**：
```python
from llama_index.core.memory import Memory

chat_memory = Memory.from_defaults()
await chat_memory.aput(user_message)

# 多轮对话
for i in range(3):
    response = await llm.achat(chat_memory.get_all())
    await chat_memory.aput(response.message)
```

2. **动态追加内容块**：
```python
# 初始消息
message = ChatMessage(role="user", content="分析这个屏幕")

# 追加 UI 状态
message.blocks.append(TextBlock(text=f"UI: {ui_state}"))

# 追加截图
message.blocks.append(ImageBlock(image=screenshot))
```

3. **格式化 UI 状态**：
```python
# 复用 DroidRun 的格式化函数
from droidrun.agent.utils.chat_utils import _format_ui_elements

formatted_ui = _format_ui_elements(state_data)
ui_block = TextBlock(text=f"UI元素:\n{formatted_ui}")
```

### 7.2 如果你想在 DroidRun 中使用 test_screen_analysis.py 的技术

1. **流式输出**：
```python
# 在 _get_llm_response 中
response_stream = self.llm.stream_chat(messages=messages_to_send)
for chunk in response_stream:
    print(chunk.delta, end="", flush=True)
```

2. **保存详细分析结果**：
```python
# 在 finalize 步骤中
analysis_file = Path(f"analysis_{timestamp}.md")
with open(analysis_file, "w", encoding="utf-8") as f:
    f.write(self.chat_memory.get_all())
```

3. **添加防重复参数**：
```python
# 在 load_llm 中
llm = load_llm(
    ...,
    frequency_penalty=0.05,
    presence_penalty=0.05,
)
```

---

## 八、总结

### test_screen_analysis.py 的优势
- 🎯 **简单直接**：适合快速验证和实验
- 📊 **完整记录**：保存截图、状态、分析结果
- 🚀 **快速迭代**：调整提示词和参数很方便
- 💡 **易于理解**：代码逻辑清晰，适合学习

### DroidRun 的优势
- 🏗️ **架构完善**：Workflow + ReAct + Memory + Events
- 🔄 **多轮交互**：支持复杂任务的迭代执行
- 🛠️ **工具丰富**：动态工具注入 + 代码执行
- 📈 **可扩展性**：Persona 系统支持专业化代理
- 🔍 **轨迹追踪**：EpisodicMemory 记录完整执行历史

### 关键启示

1. **图片提交本质相同**：都使用 `ImageBlock(image=bytes)`
2. **差异在于架构**：单次 vs 多轮，静态 vs 动态
3. **UI 状态格式化**：自然语言格式更友好
4. **上下文管理**：Memory 是多轮对话的关键
5. **提示词设计**：根据任务类型（分析 vs 执行）调整

---

## 九、代码位置索引

| 功能 | test_screen_analysis.py | DroidRun |
|-----|------------------------|----------|
| **图片提交** | 90-94 行 | codeact_agent.py:173-182<br>chat_utils.py:121-128 |
| **UI 状态处理** | 66-88 行 | chat_utils.py:50-119 |
| **提示词构建** | 68-88 行 | codeact_agent.py:126-135<br>prompts.py:10-13 |
| **LLM 调用** | 102-117 行 | codeact_agent.py:348-428 |
| **历史管理** | 无 | codeact_agent.py:430-448 |
| **结果保存** | 120-160 行 | context/episodic_memory.py |

---

## 附录：完整流程图

### test_screen_analysis.py 流程
```
main()
  ├─ AdbTools(use_tcp=True)
  ├─ get_screenshot_and_state()
  │   ├─ take_screenshot() → screenshot_bytes
  │   └─ get_state() → state_data
  ├─ load_llm()
  ├─ analyze_screen_with_llm()
  │   ├─ 构建 prompt (包含 JSON)
  │   ├─ 创建 content_blocks [TextBlock, ImageBlock]
  │   ├─ stream_chat([message], **extra_params)
  │   └─ 流式输出结果
  └─ save_analysis_result()
      ├─ 保存 screenshot_*.png
      ├─ 保存 state_*.json
      └─ 保存 analysis_*.md
```

### DroidRun CodeActAgent 流程
```
run() [Workflow]
  ├─ prepare_chat()
  │   ├─ 创建 user_message (goal)
  │   └─ chat_memory.aput(user_message)
  ├─ handle_llm_input() [循环 max_steps 次]
  │   ├─ 动态注入上下文
  │   │   ├─ add_screenshot_image_block()
  │   │   ├─ add_ui_text_block() [格式化]
  │   │   └─ add_phone_state_block()
  │   ├─ _get_llm_response()
  │   │   ├─ _limit_history()
  │   │   ├─ llm.achat([system_prompt] + history)
  │   │   └─ 保存到 EpisodicMemory
  │   └─ extract_code_and_thought()
  ├─ execute_code()
  │   ├─ SimpleCodeExecutor.execute(code)
  │   └─ 记录 screenshots/ui_states
  ├─ handle_execution_result()
  │   └─ chat_memory.aput(observation)
  └─ finalize()
      ├─ _add_final_state_observation()
      └─ 返回 StopEvent(result)
```

---

**创建时间**：2025-10-29
**作者**：Claude Code
**参考文件**：
- test/test_screen_analysis.py
- droidrun/agent/codeact/codeact_agent.py
- droidrun/agent/utils/chat_utils.py
- notes/DroidRun项目代码结构详解.md

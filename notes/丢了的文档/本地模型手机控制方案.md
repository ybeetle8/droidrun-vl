# æœ¬åœ°æ¨¡å‹æ‰‹æœºæ§åˆ¶æ–¹æ¡ˆ

## ä¸€ã€æ ¸å¿ƒè®¾è®¡æ€è·¯

### 1.1 æŒ‘æˆ˜ä¸çº¦æŸ
- **æœ¬åœ°æ¨¡å‹ä¸Šä¸‹æ–‡é™åˆ¶**ï¼šé€šå¸¸ 4K-32K tokensï¼Œè¿œå°äºäº‘ç«¯æ¨¡å‹
- **æ¨ç†é€Ÿåº¦**ï¼šéœ€è¦æ§åˆ¶å•æ¬¡æ¨ç†æ—¶é—´åœ¨å¯æ¥å—èŒƒå›´ï¼ˆ< 10ç§’ï¼‰
- **å¤šæ¨¡æ€èƒ½åŠ›**ï¼šæˆªå›¾ + UIçŠ¶æ€ JSON ä¼šå¿«é€Ÿæ¶ˆè€— token
- **ä»»åŠ¡å¤æ‚åº¦**ï¼šéœ€è¦å°†å¤æ‚ä»»åŠ¡æ‹†è§£ä¸ºç®€å•çš„å•æ­¥æ“ä½œ

### 1.2 è®¾è®¡åŸåˆ™
1. **çŠ¶æ€å‹ç¼©ä¼˜å…ˆ**ï¼šç²¾ç®€ UI çŠ¶æ€ä¿¡æ¯ï¼Œåªä¿ç•™å¯æ“ä½œå…ƒç´ 
2. **å•æ­¥å†³ç­–æ¨¡å¼**ï¼šæ¯æ¬¡åªè®©æ¨¡å‹å†³ç­–ä¸‹ä¸€æ­¥æ“ä½œï¼Œä¸è§„åˆ’é•¿æœŸè®¡åˆ’
3. **å·¥å…·è°ƒç”¨ä¼˜åŒ–**ï¼šä½¿ç”¨ç»“æ„åŒ–è¾“å‡ºï¼ˆJSONï¼‰è€Œéè‡ªç„¶è¯­è¨€
4. **è§†è§‰ç†è§£å¯é€‰**ï¼šç®€å•ä»»åŠ¡åªç”¨ UI çŠ¶æ€ï¼Œå¤æ‚ä»»åŠ¡æ‰åŠ è½½æˆªå›¾
5. **çŠ¶æ€ç¼“å­˜æœºåˆ¶**ï¼šç›¸ä¼¼åœºæ™¯å¤ç”¨å†³ç­–ï¼Œå‡å°‘æ¨ç†æ¬¡æ•°

---

## äºŒã€æ¶æ„è®¾è®¡

### 2.1 ç®€åŒ–çš„ä¸¤å±‚æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     ControlLoop (æ§åˆ¶å¾ªç¯)          â”‚
â”‚  - ä»»åŠ¡ç›®æ ‡ç®¡ç†                      â”‚
â”‚  - ç»ˆæ­¢æ¡ä»¶åˆ¤æ–­                      â”‚
â”‚  - å†å²è®°å½•ï¼ˆæ»‘åŠ¨çª—å£ï¼‰              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    ActionAgent (åŠ¨ä½œä»£ç†)           â”‚
â”‚  - æ¥æ”¶å½“å‰çŠ¶æ€                      â”‚
â”‚  - å†³ç­–ä¸‹ä¸€æ­¥æ“ä½œ                    â”‚
â”‚  - è¿”å›å·¥å…·è°ƒç”¨ï¼ˆJSONï¼‰              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      ToolExecutor (å·¥å…·æ‰§è¡Œå™¨)      â”‚
â”‚  - æ‰§è¡Œç‚¹å‡»ã€æ»‘åŠ¨ã€è¾“å…¥ç­‰æ“ä½œ        â”‚
â”‚  - è¿”å›æ‰§è¡Œç»“æœ                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**å»æ‰ PlannerAgent**ï¼š
- æœ¬åœ°æ¨¡å‹åšé•¿æœŸè§„åˆ’æ•ˆæœå·®ï¼Œä¸”æ¶ˆè€—å¤§é‡ token
- æ”¹ä¸ºåœ¨ ControlLoop ä¸­ç»´æŠ¤ç®€å•çš„ä»»åŠ¡ç›®æ ‡å³å¯

### 2.2 æ ¸å¿ƒç»„ä»¶

#### A. ControlLoopï¼ˆæ§åˆ¶å¾ªç¯ï¼‰
```python
class ControlLoop:
    """
    æ§åˆ¶å¾ªç¯ï¼Œç®¡ç†ä»»åŠ¡æ‰§è¡Œ
    """
    def __init__(self, goal: str, max_steps: int = 20):
        self.goal = goal  # ä»»åŠ¡ç›®æ ‡
        self.max_steps = max_steps  # æœ€å¤§æ­¥æ•°
        self.history = []  # æ“ä½œå†å²ï¼ˆæ»‘åŠ¨çª—å£ï¼Œåªä¿ç•™æœ€è¿‘5æ­¥ï¼‰
        self.step_count = 0

    def should_stop(self, state: dict, last_action: dict) -> bool:
        """åˆ¤æ–­æ˜¯å¦åº”è¯¥åœæ­¢"""
        # 1. è¾¾åˆ°æœ€å¤§æ­¥æ•°
        # 2. é‡å¤æ“ä½œæ£€æµ‹ï¼ˆè¿ç»­3æ¬¡ç›¸åŒæ“ä½œï¼‰
        # 3. ç›®æ ‡å®Œæˆæ£€æµ‹ï¼ˆç®€å•å…³é”®è¯åŒ¹é…æˆ–è®©æ¨¡å‹åˆ¤æ–­ï¼‰
        pass

    def run(self):
        """ä¸»å¾ªç¯"""
        while not self.should_stop():
            state = self.get_current_state()  # è·å–çŠ¶æ€
            action = self.agent.decide(state, self.goal, self.history)  # å†³ç­–
            result = self.execute(action)  # æ‰§è¡Œ
            self.history.append((state, action, result))  # è®°å½•
            self.step_count += 1
```

#### B. ActionAgentï¼ˆåŠ¨ä½œä»£ç†ï¼‰
```python
class ActionAgent:
    """
    åŠ¨ä½œä»£ç†ï¼Œè´Ÿè´£å•æ­¥å†³ç­–
    """
    def __init__(self, llm, use_vision: bool = False):
        self.llm = llm
        self.use_vision = use_vision

    def decide(self, state: dict, goal: str, history: list) -> dict:
        """
        å†³ç­–ä¸‹ä¸€æ­¥æ“ä½œ

        Returns:
            {
                "action": "click|swipe|input|wait|finish",
                "params": {...}
            }
        """
        prompt = self._build_prompt(state, goal, history)
        response = self.llm.chat(prompt)
        return self._parse_action(response)

    def _build_prompt(self, state, goal, history):
        """æ„å»ºæç¤ºè¯ï¼ˆæ ¸å¿ƒä¼˜åŒ–ç‚¹ï¼‰"""
        # 1. å‹ç¼© UI çŠ¶æ€ï¼ˆåªä¿ç•™å¯æ“ä½œå…ƒç´ ï¼‰
        # 2. å†å²åªä¿ç•™æœ€è¿‘3æ­¥
        # 3. æ˜ç¡®è¦æ±‚è¿”å› JSON æ ¼å¼
        pass
```

#### C. StateCompressorï¼ˆçŠ¶æ€å‹ç¼©å™¨ï¼‰
```python
class StateCompressor:
    """
    å‹ç¼© UI çŠ¶æ€ä¿¡æ¯ï¼Œå‡å°‘ token æ¶ˆè€—
    """
    @staticmethod
    def compress(state_data: dict, keep_vision: bool = False) -> dict:
        """
        å‹ç¼©ç­–ç•¥ï¼š
        1. åªä¿ç•™å¯æ“ä½œå…ƒç´ ï¼ˆclickable=True, long_clickable=True, scrollable=Trueï¼‰
        2. ç§»é™¤å†—ä½™å­—æ®µï¼ˆclass, package ç­‰ï¼‰
        3. åˆå¹¶ç›¸é‚»çš„åŒç±»å…ƒç´ ï¼ˆå¦‚åˆ—è¡¨é¡¹ï¼‰
        4. æˆªå›¾å¯é€‰ï¼ˆéœ€è¦æ—¶æ‰ç¼–ç ä¸º base64ï¼‰

        Returns:
            {
                "screen_size": [1080, 1920],
                "clickable_elements": [
                    {"index": 0, "text": "æœç´¢", "bounds": [x, y, w, h], "type": "button"},
                    {"index": 1, "text": "å•†å“1", "bounds": [...], "type": "item"}
                ],
                "scrollable_areas": [{"bounds": [...], "direction": "vertical"}],
                "current_activity": "com.example.MainActivity"
            }
        """
        compressed = {
            "screen_size": state_data.get("screen_size", [1080, 1920]),
            "clickable_elements": [],
            "scrollable_areas": [],
            "current_activity": state_data.get("activity", "")
        }

        # éå† UI æ ‘ï¼Œæå–å¯æ“ä½œå…ƒç´ 
        for node in state_data.get("nodes", []):
            if node.get("clickable") or node.get("text"):
                compressed["clickable_elements"].append({
                    "index": len(compressed["clickable_elements"]),
                    "text": node.get("text", ""),
                    "content_desc": node.get("content_desc", ""),
                    "bounds": node.get("bounds"),
                    "type": StateCompressor._infer_type(node)
                })

            if node.get("scrollable"):
                compressed["scrollable_areas"].append({
                    "bounds": node.get("bounds"),
                    "direction": "vertical" if node.get("bounds")[3] > node.get("bounds")[2] else "horizontal"
                })

        return compressed

    @staticmethod
    def _infer_type(node: dict) -> str:
        """æ¨æ–­å…ƒç´ ç±»å‹"""
        class_name = node.get("class", "").lower()
        if "button" in class_name:
            return "button"
        elif "edittext" in class_name:
            return "input"
        elif "textview" in class_name:
            return "text"
        elif "image" in class_name:
            return "image"
        else:
            return "unknown"
```

---

## ä¸‰ã€æç¤ºè¯è®¾è®¡ï¼ˆå…³é”®ï¼‰

### 3.1 ç³»ç»Ÿæç¤ºè¯
```
ä½ æ˜¯ä¸€ä¸ªæ‰‹æœºæ“ä½œåŠ©æ‰‹ï¼Œèƒ½å¤Ÿç†è§£ç”¨æˆ·éœ€æ±‚å¹¶æ§åˆ¶æ‰‹æœºå®Œæˆä»»åŠ¡ã€‚

**æ“ä½œè§„åˆ™ï¼š**
1. æ¯æ¬¡åªè¿”å›ä¸€ä¸ªæ“ä½œï¼Œä½¿ç”¨ä¸¥æ ¼çš„JSONæ ¼å¼
2. å¯ç”¨æ“ä½œç±»å‹ï¼šclickï¼ˆç‚¹å‡»ï¼‰ã€swipeï¼ˆæ»‘åŠ¨ï¼‰ã€inputï¼ˆè¾“å…¥ï¼‰ã€waitï¼ˆç­‰å¾…ï¼‰ã€finishï¼ˆå®Œæˆï¼‰
3. ä¼˜å…ˆä½¿ç”¨indexç´¢å¼•è¿›è¡Œç‚¹å‡»ï¼Œè€Œä¸æ˜¯åæ ‡
4. æ“ä½œå‰ä»”ç»†æ£€æŸ¥UIçŠ¶æ€ï¼Œé¿å…é‡å¤æ“ä½œ
5. å¦‚æœè¿ç»­3æ­¥æ— è¿›å±•ï¼Œå°è¯•è¿”å›ä¸Šä¸€é¡µæˆ–é‡æ–°è§„åˆ’

**è¿”å›æ ¼å¼ï¼ˆå¿…é¡»ä¸¥æ ¼éµå®ˆï¼‰ï¼š**
{
    "thought": "ç®€çŸ­çš„æ€è€ƒè¿‡ç¨‹ï¼Œä¸€å¥è¯",
    "action": "æ“ä½œç±»å‹",
    "params": {å…·ä½“å‚æ•°}
}

**ç¤ºä¾‹ï¼š**
ç‚¹å‡»æ“ä½œï¼š
{
    "thought": "éœ€è¦ç‚¹å‡»æœç´¢æ¡†è¾“å…¥å•†å“åç§°",
    "action": "click",
    "params": {"index": 0}
}

æ»‘åŠ¨æ“ä½œï¼š
{
    "thought": "éœ€è¦å‘ä¸‹æ»šåŠ¨æŸ¥çœ‹æ›´å¤šå•†å“",
    "action": "swipe",
    "params": {"direction": "down", "distance": 500}
}

è¾“å…¥æ“ä½œï¼š
{
    "thought": "åœ¨æœç´¢æ¡†ä¸­è¾“å…¥'æ‰‹æœº'",
    "action": "input",
    "params": {"text": "æ‰‹æœº"}
}

å®Œæˆæ“ä½œï¼š
{
    "thought": "å·²æ‰¾åˆ°ç›®æ ‡å•†å“ï¼Œä»»åŠ¡å®Œæˆ",
    "action": "finish",
    "params": {}
}
```

### 3.2 ç”¨æˆ·æç¤ºè¯æ¨¡æ¿
```python
def build_user_prompt(goal: str, state: dict, history: list) -> str:
    """æ„å»ºç”¨æˆ·æç¤ºè¯"""

    # å†å²è®°å½•ï¼ˆåªä¿ç•™æœ€è¿‘3æ­¥ï¼‰
    recent_history = history[-3:] if len(history) > 3 else history
    history_text = ""
    for i, (s, a, r) in enumerate(recent_history):
        history_text += f"\nç¬¬{len(history)-len(recent_history)+i+1}æ­¥: {a['action']} -> {r.get('success', False)}"

    # å‹ç¼©åçš„çŠ¶æ€
    compressed_state = json.dumps(state, ensure_ascii=False, indent=2)

    prompt = f"""**ä»»åŠ¡ç›®æ ‡ï¼š**
{goal}

**å†å²æ“ä½œï¼š**{history_text if history_text else "\nï¼ˆé¦–æ¬¡æ“ä½œï¼‰"}

**å½“å‰å±å¹•çŠ¶æ€ï¼š**
```json
{compressed_state}
```

**è¯·å†³ç­–ä¸‹ä¸€æ­¥æ“ä½œï¼ˆä¸¥æ ¼è¿”å›JSONæ ¼å¼ï¼‰ï¼š**"""

    return prompt
```

---

## å››ã€Token ä¼˜åŒ–ç­–ç•¥

### 4.1 è¾“å…¥ä¼˜åŒ–
| ä¼˜åŒ–é¡¹ | åŸå§‹ | ä¼˜åŒ–å | èŠ‚çœ |
|--------|------|--------|------|
| UIçŠ¶æ€å®Œæ•´JSON | ~2000 tokens | ~300 tokens | 85% |
| å†å²è®°å½•å…¨éƒ¨ | ~500 tokens | ~100 tokens | 80% |
| æˆªå›¾ (å¯é€‰) | ~800 tokens | 0-800 tokens | 0-100% |
| ç³»ç»Ÿæç¤ºè¯ | ~400 tokens | ~300 tokens | 25% |
| **æ€»è®¡** | **~3700 tokens** | **~700 tokens** | **81%** |

### 4.2 è¾“å‡ºä¼˜åŒ–
- é™åˆ¶ max_tokens=200ï¼ˆä¸€ä¸ªæ“ä½œä¸éœ€è¦é•¿æ–‡æœ¬ï¼‰
- ä½¿ç”¨ stop_tokens=["```", "\n\n\n"] æå‰ç»ˆæ­¢ç”Ÿæˆ
- è¦æ±‚æ¨¡å‹è¿”å›ç»“æ„åŒ– JSONï¼Œé¿å…å†—é•¿è§£é‡Š

### 4.3 è§†è§‰ç†è§£æŒ‰éœ€åŠ è½½
```python
def should_use_vision(goal: str, state: dict, history: list) -> bool:
    """
    åˆ¤æ–­æ˜¯å¦éœ€è¦åŠ è½½æˆªå›¾

    è§„åˆ™ï¼š
    1. UIçŠ¶æ€ä¸­æ²¡æœ‰æ–‡æœ¬ä¿¡æ¯ï¼ˆçº¯å›¾æ ‡ç•Œé¢ï¼‰
    2. ä»»åŠ¡æ¶‰åŠéªŒè¯ç ã€å›¾ç‰‡è¯†åˆ«
    3. è¿ç»­3æ­¥æ“ä½œå¤±è´¥ï¼ˆå¯èƒ½UIè§£æä¸å‡†ç¡®ï¼‰
    4. ç›®æ ‡åŒ…å«"é¢œè‰²"ã€"å›¾ç‰‡"ã€"æ ·å¼"ç­‰å…³é”®è¯
    """
    # æ£€æŸ¥UIçŠ¶æ€æ˜¯å¦æœ‰è¶³å¤Ÿä¿¡æ¯
    text_count = sum(1 for elem in state.get("clickable_elements", []) if elem.get("text"))

    if text_count < 3:  # æ–‡æœ¬ä¿¡æ¯å¤ªå°‘
        return True

    # æ£€æŸ¥ä»»åŠ¡å…³é”®è¯
    vision_keywords = ["å›¾ç‰‡", "é¢œè‰²", "æ ·å¼", "éªŒè¯ç ", "è¯†åˆ«", "å›¾æ ‡"]
    if any(kw in goal for kw in vision_keywords):
        return True

    # æ£€æŸ¥å†å²å¤±è´¥æ¬¡æ•°
    if len(history) >= 3 and all(not h[2].get("success") for h in history[-3:]):
        return True

    return False
```

---

## äº”ã€å®ç°ç¤ºä¾‹ä»£ç 

### 5.1 ä¸»æ§åˆ¶å¾ªç¯
```python
class SimplePhoneController:
    """ç®€åŒ–çš„æ‰‹æœºæ§åˆ¶å™¨"""

    def __init__(self, adb_tools, llm, max_steps=20):
        self.adb = adb_tools
        self.llm = llm
        self.max_steps = max_steps
        self.history = []
        self.step_count = 0

    def run(self, goal: str):
        """æ‰§è¡Œä»»åŠ¡"""
        print(f"ğŸ¯ ä»»åŠ¡ç›®æ ‡: {goal}")

        while self.step_count < self.max_steps:
            # 1. è·å–å¹¶å‹ç¼©çŠ¶æ€
            raw_state = self.adb.get_state()
            screenshot = None

            use_vision = should_use_vision(goal, raw_state, self.history)
            if use_vision:
                _, screenshot = self.adb.take_screenshot()

            compressed_state = StateCompressor.compress(raw_state)

            # 2. æ„å»ºæç¤ºè¯
            prompt = build_user_prompt(goal, compressed_state, self.history)

            # 3. è°ƒç”¨æ¨¡å‹å†³ç­–
            action = self.decide_action(prompt, screenshot)

            # 4. æ‰§è¡Œæ“ä½œ
            result = self.execute_action(action)

            # 5. è®°å½•å†å²
            self.history.append((compressed_state, action, result))
            self.step_count += 1

            print(f"æ­¥éª¤ {self.step_count}: {action['action']} -> {result.get('success')}")

            # 6. æ£€æŸ¥ç»ˆæ­¢æ¡ä»¶
            if action['action'] == 'finish':
                print("âœ… ä»»åŠ¡å®Œæˆï¼")
                break

            if self.should_stop(action, result):
                print("âš ï¸ æ£€æµ‹åˆ°å¾ªç¯æˆ–å¡æ­»ï¼Œç»ˆæ­¢æ‰§è¡Œ")
                break

        return self.history

    def decide_action(self, prompt: str, screenshot: bytes = None) -> dict:
        """è°ƒç”¨æ¨¡å‹å†³ç­–"""
        messages = []

        if screenshot:
            messages.append(ChatMessage(
                role=MessageRole.USER,
                content=[
                    TextBlock(text=prompt),
                    ImageBlock(image=screenshot)
                ]
            ))
        else:
            messages.append(ChatMessage(
                role=MessageRole.USER,
                content=prompt
            ))

        response = self.llm.chat(
            messages,
            max_tokens=200,
            temperature=0.1,
            frequency_penalty=0.05,
            presence_penalty=0.05
        )

        # è§£æJSON
        try:
            action = json.loads(response.message.content)
            return action
        except:
            print(f"âŒ æ¨¡å‹è¿”å›æ ¼å¼é”™è¯¯: {response.message.content}")
            return {"action": "wait", "params": {}}

    def execute_action(self, action: dict) -> dict:
        """æ‰§è¡Œæ“ä½œ"""
        action_type = action.get("action")
        params = action.get("params", {})

        try:
            if action_type == "click":
                if "index" in params:
                    result = self.adb.click(index=params["index"])
                else:
                    result = self.adb.click(x=params["x"], y=params["y"])
                return {"success": True, "result": result}

            elif action_type == "swipe":
                direction = params.get("direction", "down")
                distance = params.get("distance", 500)
                result = self.adb.swipe(direction=direction, distance=distance)
                return {"success": True, "result": result}

            elif action_type == "input":
                text = params.get("text", "")
                result = self.adb.input_text(text)
                return {"success": True, "result": result}

            elif action_type == "wait":
                import time
                time.sleep(2)
                return {"success": True}

            elif action_type == "finish":
                return {"success": True}

            else:
                return {"success": False, "error": "æœªçŸ¥æ“ä½œç±»å‹"}

        except Exception as e:
            return {"success": False, "error": str(e)}

    def should_stop(self, action: dict, result: dict) -> bool:
        """åˆ¤æ–­æ˜¯å¦åº”è¯¥åœæ­¢"""
        # 1. è¿ç»­å¤±è´¥æ£€æµ‹
        if len(self.history) >= 3:
            recent_failures = [not h[2].get("success") for h in self.history[-3:]]
            if all(recent_failures):
                return True

        # 2. é‡å¤æ“ä½œæ£€æµ‹
        if len(self.history) >= 3:
            recent_actions = [h[1].get("action") for h in self.history[-3:]]
            if len(set(recent_actions)) == 1:  # è¿ç»­3æ¬¡ç›¸åŒæ“ä½œ
                return True

        return False
```

### 5.2 ä½¿ç”¨ç¤ºä¾‹
```python
# é…ç½®
API_BASE = "http://192.168.18.9:8080/v1"
MODEL = "/models"

# åˆå§‹åŒ–
adb = AdbTools(use_tcp=True)
llm = load_llm(
    provider_name="OpenAILike",
    model=MODEL,
    api_base=API_BASE,
    temperature=0.1,
    max_tokens=200
)

# åˆ›å»ºæ§åˆ¶å™¨
controller = SimplePhoneController(adb, llm, max_steps=20)

# æ‰§è¡Œä»»åŠ¡
controller.run("æ‰“å¼€æ·˜å®ï¼Œæœç´¢'æ‰‹æœº'ï¼Œç‚¹å‡»ç¬¬ä¸€ä¸ªå•†å“")
```

---

## å…­ã€è¿›é˜¶ä¼˜åŒ–

### 6.1 åŠ¨ä½œç¼“å­˜ï¼ˆç›¸ä¼¼åœºæ™¯å¤ç”¨ï¼‰
```python
class ActionCache:
    """ç¼“å­˜ç›¸ä¼¼åœºæ™¯çš„å†³ç­–ç»“æœ"""

    def __init__(self, similarity_threshold=0.8):
        self.cache = {}  # {state_hash: action}
        self.threshold = similarity_threshold

    def get(self, state: dict) -> dict | None:
        """æŸ¥æ‰¾ç›¸ä¼¼çŠ¶æ€çš„ç¼“å­˜å†³ç­–"""
        state_hash = self._hash_state(state)
        return self.cache.get(state_hash)

    def set(self, state: dict, action: dict):
        """ç¼“å­˜å†³ç­–"""
        state_hash = self._hash_state(state)
        self.cache[state_hash] = action

    def _hash_state(self, state: dict) -> str:
        """è®¡ç®—çŠ¶æ€å“ˆå¸Œï¼ˆç®€åŒ–ç‰ˆï¼‰"""
        # æå–å…³é”®ç‰¹å¾ï¼šactivity + å¯ç‚¹å‡»å…ƒç´ çš„æ–‡æœ¬
        key_features = [
            state.get("current_activity", ""),
            *[elem.get("text", "") for elem in state.get("clickable_elements", [])]
        ]
        return "|".join(key_features)
```

### 6.2 å¤±è´¥é‡è¯•æœºåˆ¶
```python
class RetryWrapper:
    """å¤±è´¥é‡è¯•åŒ…è£…å™¨"""

    def __init__(self, max_retries=2):
        self.max_retries = max_retries

    def execute_with_retry(self, func, *args, **kwargs):
        """æ‰§è¡Œæ“ä½œï¼Œå¤±è´¥æ—¶é‡è¯•"""
        for attempt in range(self.max_retries + 1):
            try:
                result = func(*args, **kwargs)
                if result.get("success"):
                    return result
                else:
                    print(f"âš ï¸ æ“ä½œå¤±è´¥ï¼Œé‡è¯• {attempt+1}/{self.max_retries}")
            except Exception as e:
                print(f"âŒ å¼‚å¸¸: {e}ï¼Œé‡è¯• {attempt+1}/{self.max_retries}")

            if attempt < self.max_retries:
                time.sleep(1)  # ç­‰å¾…1ç§’åé‡è¯•

        return {"success": False, "error": "é‡è¯•æ¬¡æ•°è€—å°½"}
```

### 6.3 ä¸Šä¸‹æ–‡çª—å£è‡ªé€‚åº”
```python
def adaptive_history_window(history: list, max_tokens: int = 500) -> list:
    """
    æ ¹æ®tokené™åˆ¶åŠ¨æ€è°ƒæ•´å†å²çª—å£å¤§å°

    ç­–ç•¥ï¼š
    1. ä¼˜å…ˆä¿ç•™æœ€è¿‘çš„æ“ä½œ
    2. å¦‚æœtokenå……è¶³ï¼Œä¿ç•™å…³é”®æ“ä½œï¼ˆå¦‚é¦–æ¬¡ç‚¹å‡»ã€è¾“å…¥ç­‰ï¼‰
    3. å‹ç¼©ä¸­é—´æ­¥éª¤ï¼ˆåªä¿ç•™actionç±»å‹ï¼Œå»æ‰è¯¦ç»†stateï¼‰
    """
    if len(history) <= 3:
        return history

    # è®¡ç®—æ¯æ¡å†å²çš„tokenæ¶ˆè€—ï¼ˆç®€åŒ–ä¼°ç®—ï¼‰
    def estimate_tokens(item):
        state, action, result = item
        return len(json.dumps(state)) // 4 + len(json.dumps(action)) // 4

    # æ€»æ˜¯ä¿ç•™æœ€è¿‘3æ­¥
    recent = history[-3:]
    remaining_tokens = max_tokens - sum(estimate_tokens(h) for h in recent)

    # å°è¯•æ·»åŠ æ›´æ—©çš„å…³é”®æ­¥éª¤
    key_actions = ["click", "input"]
    selected = []
    for item in reversed(history[:-3]):
        if item[1].get("action") in key_actions and remaining_tokens > 0:
            tokens = estimate_tokens(item)
            if tokens <= remaining_tokens:
                selected.insert(0, item)
                remaining_tokens -= tokens

    return selected + recent
```

---

## ä¸ƒã€æ€§èƒ½é¢„æœŸ

### 7.1 Token æ¶ˆè€—
- **å•æ­¥å†³ç­–**: çº¦ 700-1500 tokensï¼ˆä¸å«æˆªå›¾ï¼‰/ 1500-2300 tokensï¼ˆå«æˆªå›¾ï¼‰
- **20æ­¥ä»»åŠ¡**: çº¦ 14K-30K tokensï¼ˆ4K ä¸Šä¸‹æ–‡å¯èƒ½ä¸å¤Ÿï¼Œå»ºè®® 8K ä»¥ä¸Šï¼‰

### 7.2 é€Ÿåº¦é¢„æœŸ
- **æœ¬åœ°æ¨ç†é€Ÿåº¦**: å‡è®¾ 10 tokens/sï¼Œå•æ­¥å†³ç­– 70-230 ç§’ï¼ˆå¤ªæ…¢ï¼ï¼‰
- **ä¼˜åŒ–å»ºè®®**: ä½¿ç”¨é‡åŒ–æ¨¡å‹ï¼ˆQ4/Q8ï¼‰+ GPUåŠ é€Ÿï¼Œç›®æ ‡ 30-50 tokens/s

### 7.3 å‡†ç¡®ç‡é¢„æœŸ
- **ç®€å•ä»»åŠ¡**ï¼ˆç‚¹å‡»ã€æ»‘åŠ¨ï¼‰: 80-90%
- **ä¸­ç­‰ä»»åŠ¡**ï¼ˆæœç´¢å•†å“ã€æµè§ˆï¼‰: 60-70%
- **å¤æ‚ä»»åŠ¡**ï¼ˆå¤šæ­¥æµç¨‹ã€æ¡ä»¶åˆ¤æ–­ï¼‰: 40-50%

---

## å…«ã€æ¨èæ¨¡å‹

| æ¨¡å‹ | å‚æ•°é‡ | ä¸Šä¸‹æ–‡ | å¤šæ¨¡æ€ | æ¨èåº¦ |
|------|--------|--------|--------|--------|
| Qwen2-VL-7B | 7B | 32K | âœ… | â­â­â­â­â­ |
| LLaVA-v1.6-34B | 34B | 4K | âœ… | â­â­â­â­ |
| InternVL2-8B | 8B | 8K | âœ… | â­â­â­â­ |
| MiniCPM-V-2.6 | 8B | 8K | âœ… | â­â­â­â­ |

**æ¨èé…ç½®**ï¼š
- **é¦–é€‰**: Qwen2-VL-7B (æ”¯æŒé•¿ä¸Šä¸‹æ–‡ï¼Œå¤šæ¨¡æ€èƒ½åŠ›å¼º)
- **é‡åŒ–**: Q4_K_Mï¼ˆé€Ÿåº¦å’Œç²¾åº¦å¹³è¡¡ï¼‰
- **ç¡¬ä»¶**: RTX 3090/4090 æˆ–æ›´é«˜

---

## ä¹ã€æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹
1. **åŒ–ç¹ä¸ºç®€**: å»æ‰å¤æ‚çš„è§„åˆ’å±‚ï¼Œæ”¹ä¸ºå•æ­¥å†³ç­–
2. **çŠ¶æ€å‹ç¼©**: UIçŠ¶æ€ä»2000 tokenså‹ç¼©åˆ°300 tokens
3. **æŒ‰éœ€è§†è§‰**: åªåœ¨å¿…è¦æ—¶ä½¿ç”¨æˆªå›¾ï¼ŒèŠ‚çœtoken
4. **ç»“æ„åŒ–è¾“å‡º**: è¦æ±‚JSONæ ¼å¼ï¼Œé¿å…å†—é•¿è§£é‡Š
5. **æ»‘åŠ¨çª—å£**: å†å²è®°å½•åªä¿ç•™æœ€è¿‘3-5æ­¥

### å®ç°ä¼˜å…ˆçº§
1. âœ… **P0**: å®ç° StateCompressorï¼ˆçŠ¶æ€å‹ç¼©å™¨ï¼‰
2. âœ… **P0**: å®ç° SimplePhoneControllerï¼ˆç®€å•æ§åˆ¶å¾ªç¯ï¼‰
3. âœ… **P0**: è®¾è®¡é«˜æ•ˆæç¤ºè¯æ¨¡æ¿
4. âš ï¸ **P1**: æ·»åŠ è§†è§‰ç†è§£æŒ‰éœ€åŠ è½½é€»è¾‘
5. âš ï¸ **P1**: å®ç°å¤±è´¥é‡è¯•å’Œå¾ªç¯æ£€æµ‹
6. â¸ï¸ **P2**: æ·»åŠ åŠ¨ä½œç¼“å­˜ä¼˜åŒ–
7. â¸ï¸ **P2**: å®ç°è‡ªé€‚åº”å†å²çª—å£

### ä¸‹ä¸€æ­¥è¡ŒåŠ¨
1. åŸºäº `test_screen_analysis.py` å®ç° `StateCompressor`
2. ç¼–å†™å•æ­¥å†³ç­–çš„æç¤ºè¯æ¨¡æ¿
3. æµ‹è¯•ä¸åŒå‹ç¼©çº§åˆ«ä¸‹çš„æ¨¡å‹è¡¨ç°
4. è¯„ä¼°æ˜¯å¦éœ€è¦å¼•å…¥ Few-Shot ç¤ºä¾‹ï¼ˆä¼šå¢åŠ  tokenï¼‰

---

**å…³é”®æƒè¡¡**ï¼š
- æœ¬åœ°æ¨¡å‹ = é€Ÿåº¦æ…¢ + ä¸Šä¸‹æ–‡å° + èƒ½åŠ›å¼±
- è§£å†³æ–¹æ¡ˆ = ç®€åŒ–æ¶æ„ + å‹ç¼©è¾“å…¥ + å•æ­¥å†³ç­–
- ç›®æ ‡ï¼šåœ¨ 8K ä¸Šä¸‹æ–‡å†…å®Œæˆ 10-20 æ­¥çš„ç®€å•ä»»åŠ¡

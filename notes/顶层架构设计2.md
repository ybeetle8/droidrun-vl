# 手机操作 Agent 顶层架构设计

> **设计哲学**: 模拟人类认知过程，在技术易实现的范围内构建自主学习、自我修正的手机操作 Agent

**文档版本**: v2.0
**创建时间**: 2025-11-01
**类型**: 顶层架构设计

---

## 一、核心设计理念

### 1.1 设计原则

1. **认知仿生但不过度模拟**
   - 借鉴人类的观察→思考→行动→反馈循环
   - 不追求完全模拟神经机制，聚焦可工程化的认知模式
   - 在技术易实现和效果之间取得平衡

2. **任务自主性与容错性**
   - Agent 能够自主判断任务进度和完成状态
   - 遇到异常能自动恢复，不因环境变化而中断
   - 支持长时间运行的循环任务

3. **经验积累与快速迭代**
   - 通过试错积累操作经验
   - 成功和失败的经验都成为学习素材
   - 时间越长，效率越高

---

## 二、总体架构

### 2.1 双层 Agent 架构

```
┌─────────────────────────────────────────────────────────────┐
│                     Master Agent                             │
│                  (核心任务管理层)                              │
│                                                               │
│  职责:                                                        │
│  • 任务目标管理与分解                                         │
│  • 执行进度监控与状态判断                                     │
│  • 任务完成判定                                               │
│  • 异常恢复与重启                                             │
│  • 循环任务调度                                               │
│                                                               │
└───────────────────┬─────────────────────────────────────────┘
                    │
        ┌───────────┴───────────┐
        │   任务分配 & 监督      │
        └───────────┬───────────┘
                    ▼
┌─────────────────────────────────────────────────────────────┐
│                  Execution Agent                             │
│               (执行层 / Worker Agent)                         │
│                                                               │
│  职责:                                                        │
│  • 接收子任务指令                                             │
│  • 观察屏幕并理解当前状态                                     │
│  • 决策下一步操作                                             │
│  • 执行具体动作 (点击/滑动/输入)                             │
│  • 即时反馈与试错纠正                                         │
│  • 向 Master 报告执行状态                                     │
│                                                               │
└─────────────────────────────────────────────────────────────┘
        │                                   │
        │                                   │
    ┌───▼────┐                         ┌───▼────┐
    │ 长期记忆 │                         │ 设备交互│
    │ 系统    │                         │ 层     │
    └────────┘                         └────────┘
```

---

### 2.2 Master Agent (核心任务管理)

#### 核心能力

**1. 任务理解与分解**
- 接收用户任务描述 (如: "到闲鱼 app，购买一个 200 元以内的 1Tb 硬盘")
- 理解任务意图和终止条件
- 分解为可执行的子任务序列

**2. 执行监督**
- 持续监控 Worker Agent 的执行状态
- 判断子任务是否完成
- 检测执行偏离或卡死
- 必要时接管控制权

**3. 异常恢复机制**

```
异常检测:
├─ Worker 报告失败 (如: 误触退出 App)
├─ Worker 长时间无进展 (如: 操作循环)
├─ 环境变化 (如: 突然弹窗、来电)
└─ 超时未完成

恢复策略:
├─ Level 1: 指导 Worker 重试当前操作
├─ Level 2: 重置到安全状态 (如: 重新打开 App)
├─ Level 3: 跳转到正确页面继续执行
├─ Level 4: 重新规划执行路径
└─ Level 5: 放弃任务并报告
```

**4. 任务完成判定**
- 基于多重证据判断任务完成:
  - 目标状态达成 (如: 订单提交成功)
  - 关键 UI 元素出现 (如: "支付完成"页面)
  - Worker 明确报告完成
- 记录任务执行日志
- 触发经验学习流程

**5. 循环任务调度**

```
示例: "访问 Twitter，随机浏览贴文，并善意回复，一直循环永不停止"

Master 工作流:
1. 分配单次任务: "浏览一条贴文并回复"
2. 监控 Worker 执行
3. 确认任务完成
4. 判断是否继续循环 → 是
5. 生成新任务参数 (随机选择下一条)
6. 回到步骤 1
```

---

### 2.3 Execution Agent (执行层)

#### 核心工作循环

```
初始化:
├─ 接收 Master 分配的子任务
├─ 检索长期记忆 (是否有经验可复用)
└─ 启动执行循环

主循环 (观察 → 思考 → 决策 → 执行 → 反馈):
│
├─ 步骤 1: 观察
│   ├─ 截取屏幕
│   ├─ 视觉理解 (VL 模型分析)
│   ├─ UI 元素检测
│   └─ 更新工作记忆
│
├─ 步骤 2: 思考
│   ├─ 回顾工作记忆 (过去 N 步做了什么)
│   ├─ 理解当前状态 (我在哪个页面)
│   ├─ 异常检测 (是否卡住/循环)
│   └─ 与目标对比 (距离完成还差什么)
│
├─ 步骤 3: 决策
│   ├─ 生成候选操作 (3-5 个方案)
│   ├─ 评估方案 (相关性/风险/成本)
│   ├─ 选择最佳操作
│   └─ (可选) 二次验证
│
├─ 步骤 4: 执行
│   ├─ 记录执行前状态
│   ├─ 发送操作指令 (点击/滑动/输入)
│   ├─ 等待响应 (0.5 秒)
│   └─ 即时判断结果
│
├─ 步骤 5: 反馈
│   ├─ 成功 → 更新记忆，继续下一步
│   ├─ 失败 → 回退操作，调整策略
│   ├─ 不确定 → 再次观察
│   └─ 向 Master 报告状态
│
└─ 判断子任务完成 → 退出循环 / 继续
```

#### 关键能力

**1. 工作记忆管理**
- 容量限制: 保留最近 7±2 步操作
- 循环检测: 识别 A-B-A 重复模式
- 卡住检测: 连续失败 N 次触发求助

**2. 试错与即时纠错**
- 每步操作后 0.5 秒内判断结果
- 发现错误立即回退 (按返回键)
- 调整操作参数重试

**3. 持续观察**
- 后台监控屏幕变化 (0.5 秒间隔)
- 自动处理:
  - 加载状态 → 等待
  - 弹窗 → 关闭
  - 错误提示 → 触发恢复

---

## 三、长期记忆系统

### 3.1 核心价值

> "第一次探索，第二次直达"

通过积累操作经验，使 Agent 在遇到相似任务时:
- **快速检索**: 语义搜索找到相似经验
- **直接复用**: 高置信度时直接执行经验操作
- **持续优化**: 成功率低的经验自动淘汰

---

### 3.2 经验存储结构

#### 经验记录包含

**1. 任务元数据**
- 任务描述 (如: "在闲鱼搜索硬盘并购买")
- 应用名称、版本
- 任务意图 (购物/社交/娱乐)
- 任务标签

**2. 操作序列**
- 每步操作详情:
  - 操作类型 (点击/滑动/输入)
  - 目标控件描述/坐标
  - 执行前后截图
  - 成功/失败状态
  - 耗时

**3. 关键决策点标注**
- 页面跳转点
- 搜索输入点
- 确认操作点

**4. 学习元数据**
- 创建时间
- 使用次数
- 成功率 (动态更新)
- 最后使用时间

---

### 3.3 经验检索与应用

#### 多级检索策略

```
任务输入
    ↓
检索经验
    │
    ├─ Level 1: 精确匹配 (哈希查找)
    │   → 置信度 > 0.9 → 直接执行
    │
    ├─ Level 2: 语义相似 (向量搜索)
    │   → 相似度 > 0.85 → 轻微调整后执行
    │
    ├─ Level 3: 模式匹配 (通用模板)
    │   → 匹配模式 → 引导式探索
    │
    └─ Level 4: 无匹配
        → 完全新探索 (Reflexion 循环)
```

#### 经验学习触发

- 仅在 Worker 成功完成新任务后学习
- 提取关键操作序列 (去除重复、无效操作)
- 生成语义向量并存储
- 异步执行经验泛化 (聚类相似任务)

---

### 3.4 技术实现

**轻量级方案 (推荐)**:
- **ChromaDB**: 向量语义搜索
- **SQLite/JSON**: 存储完整经验数据
- **嵌入模型**: multilingual-MiniLM

**高级方案**:
- **Qdrant/Milvus**: 大规模向量搜索
- **Neo4j**: 任务关系图谱
- **PostgreSQL**: 元数据与统计

---

## 四、典型任务场景

### 场景 1: 单次购物任务

**用户指令**: "到闲鱼 app，购买一个 200 元以内的 1Tb 硬盘"

**Master 工作流**:
1. 分解任务:
   - 子任务 1: 打开闲鱼 App
   - 子任务 2: 搜索 "1Tb 硬盘"
   - 子任务 3: 筛选价格 ≤ 200 元
   - 子任务 4: 选择商品并购买
   - 子任务 5: 确认订单提交

2. 执行监督:
   - Worker 执行子任务 1 → 成功 → 继续
   - Worker 执行子任务 2 → 误触退出 App → **异常检测**

3. 异常恢复:
   - Master 检测到 Worker 不在闲鱼 App
   - 判断: 子任务 2 未完成
   - 恢复操作: 重新打开闲鱼
   - 跳转到搜索页面
   - 继续子任务 2

4. 任务完成判定:
   - Worker 报告订单提交成功
   - 验证: 检测到 "订单已提交" 页面
   - Master 确认任务完成 → 记录日志 → 结束

---

### 场景 2: 循环任务

**用户指令**: "访问 Twitter，随机浏览贴文，并善意回复，一直循环永不停止"

**Master 工作流**:
1. 初始化:
   - 识别为永久循环任务
   - 设置循环计数器 = ∞

2. 单次任务循环:
   ```
   循环开始:
   ├─ 分配任务: "浏览一条贴文并回复"
   ├─ Worker 执行:
   │   ├─ 打开 Twitter
   │   ├─ 随机滑动选择贴文
   │   ├─ 阅读内容
   │   ├─ 生成善意回复
   │   ├─ 找到回复按钮
   │   ├─ 输入文字
   │   └─ 点击发送
   ├─ Master 确认完成:
   │   └─ 检测到 "回复已发送" 状态
   ├─ 短暂休息 (随机 30-60 秒, 模拟人类行为)
   └─ 回到循环开始
   ```

3. 异常处理:
   - 如遇到网络错误 → 等待恢复
   - 如账号被限制 → 暂停并通知用户
   - 如误触退出 → 重新打开 Twitter

**关键点**: Master 永远不会判定任务"最终完成"，而是无限调度

---

## 五、经验积累示例

### 5.1 首次执行 (探索模式)

**任务**: "打开淘宝，搜索双肩包"

**Worker 探索过程**:
```
步骤 1: 观察屏幕 → 识别到桌面
步骤 2: 决策 → 寻找淘宝 App 图标 → 未找到
步骤 3: 调整 → 滑动屏幕查找 → 找到
步骤 4: 执行 → 点击淘宝 → 启动 App
步骤 5: 等待加载 → 检测到首页
步骤 6: 观察 → 寻找搜索框 → 定位到顶部
步骤 7: 执行 → 点击搜索框 → 成功
步骤 8: 执行 → 输入 "双肩包" → 成功
步骤 9: 执行 → 点击搜索按钮 → 成功
步骤 10: 验证 → 看到搜索结果页 → 完成
```

**经验保存**:
- 任务描述: "在淘宝搜索商品"
- 关键步骤: [打开 App → 点击搜索框 → 输入关键词 → 点击搜索]
- UI 元素记忆:
  - 淘宝搜索框: 通常在顶部，白色背景，带放大镜图标
  - 搜索按钮: 搜索框右侧
- 成功率: 1.0 (首次)

---

### 5.2 第二次执行 (经验复用)

**任务**: "打开淘宝，搜索帐篷"

**Worker 工作流**:
```
步骤 1: 检索经验 → 找到 "在淘宝搜索商品" (相似度 0.95)
步骤 2: 直接复用:
   ├─ 打开淘宝 (已知位置)
   ├─ 点击搜索框 (已知位置: 顶部中心)
   ├─ 输入 "帐篷"
   └─ 点击搜索
步骤 3: 完成 (耗时缩短 5 倍)
```

**经验更新**:
- 使用次数: 2
- 成功率: 1.0 (平滑更新)
- 最后使用时间: 更新

---

### 5.3 经验泛化

**聚类发现**:
- "在淘宝搜索双肩包"
- "在淘宝搜索帐篷"
- "在淘宝搜索手机壳"

**提取通用模式**:
```
模式: "在 {app} 搜索 {关键词}"
通用路径:
  1. 打开 App
  2. 定位搜索框 (通常在顶部)
  3. 点击搜索框
  4. 输入关键词 (可变)
  5. 点击搜索按钮
```

**模式应用**:
- 下次遇到 "在京东搜索键盘" → 自动应用模式 → 引导式探索

---

## 六、关键技术组件

### 6.1 视觉理解模块

**多模态感知**:
- **VL 模型** (Qwen3-VL-4B): 深度理解屏幕语义
- **UI 检测器** : droidrun的 get_state 可得到 a11y_tree
- **OCR** : 不需要单独配置, UI 检测器 可以完美完成

**注意力机制**:
- 优先处理与任务相关的区域
- 过滤无关信息 (广告、背景)

---

### 6.2 决策与推理模块

**思维链 (Chain of Thought)**:
- 不直接输出操作，先深度思考
- 生成多个候选方案
- 评估风险和成本
- 选择最佳方案

**异常检测**:
- 循环检测: 识别 A-B-A 模式
- 卡住检测: 连续 N 次无进展
- 环境变化: 弹窗、加载、错误

---

### 6.3 记忆管理模块

**工作记忆 (短期)**:
- 容量: 7±2 个操作
- 数据结构: deque (双端队列)
- 内容: 最近操作、当前目标、上下文快照

**长期记忆 (经验库)**:
- 存储: 向量数据库 + 关系数据库
- 检索: 语义搜索 + 精确匹配
- 优化: 自动淘汰低成功率经验

---

### 6.4 设备交互层

**基于 DroidRun**:
- 点击 (tap)
- 滑动 (swipe)
- 输入文本 (input)
- 按键 (press_back/press_home)
- 截屏 (screenshot)

---

## 七、系统优势

### 7.1 与传统脚本对比

| 维度 | 传统脚本 | 本系统 |
|------|---------|--------|
| 适应性 | UI 变化即失效 | 自适应变化 |
| 错误处理 | 无/被动 | 主动检测与纠正 |
| 异常恢复 | 脆弱 | 多层次恢复策略 |
| 学习能力 | 无 | 经验积累，越用越快 |
| 复杂任务 | 难以处理 | 自主分解执行 |
| 循环任务 | 需硬编码 | 自动调度 |

---

### 7.2 核心创新点

1. **双层 Agent 架构**
   - Master 提供任务级监督与恢复
   - Worker 聚焦执行与试错
   - 清晰的职责分离

2. **自主异常恢复**
   - 不因误操作而完全失败
   - 能够判断状态并返回正确路径
   - 支持长时间运行

3. **经验驱动优化**
   - 首次探索，后续直达
   - 自动提取通用模式
   - 持续学习与自我优化

4. **循环任务支持**
   - Master 负责无限调度
   - 模拟人类"完成一次→继续下一次"逻辑
   - 适用于社交互动、内容浏览等场景

---

## 八、实施路线

### Phase 1: 基础双层架构 (2-3 周)

**目标**: 实现 Master-Worker 协作

- Master Agent:
  - 任务分解与调度
  - 执行监控
  - 基础异常检测

- Worker Agent:
  - 观察→决策→执行循环
  - 工作记忆管理
  - 试错与即时纠正

- 设备交互集成

**验证**: 完成单个购物任务，包含一次异常恢复

---

### Phase 2: 长期记忆集成 (2-3 周)

**目标**: 实现经验积累与复用

- 经验存储系统 (ChromaDB + SQLite)
- 经验检索与匹配
- 经验学习节点
- 直接复用机制

**验证**: 第二次执行相同任务时速度提升 5 倍

---

### Phase 3: 高级特性 (3-4 周)

**目标**: 增强鲁棒性与智能化

- 高级异常恢复策略
- 经验泛化 (模式提取)
- 循环任务调度
- 持续观察后台任务
- 性能优化 (缓存、批量处理)

**验证**: 运行 "永久浏览回复" 循环任务 24 小时无中断

---

## 九、预期效果

### 任务执行效率

| 任务复杂度 | 首次执行 | 第二次执行 | 加速比 |
|-----------|---------|-----------|-------|
| 简单 (3-5 步) | 5-10 秒 | 1-2 秒 | 5x |
| 中等 (10-15 步) | 30-60 秒 | 5-10 秒 | 6x |
| 复杂 (20+ 步) | 2-5 分钟 | 20-40 秒 | 8x |

### 鲁棒性

- **异常恢复率**: 90%+ (误触、弹窗、退出等)
- **循环任务稳定性**: 可持续运行 24 小时+
- **成功率**: 首次 70-80%, 经验积累后 95%+

---

## 十、总结

本架构设计通过 **双层 Agent 架构** 和 **长期记忆系统** 实现:

1. **自主性**: Master 持续监督，Worker 自主执行
2. **容错性**: 多层次异常恢复，不因小错误而失败
3. **学习性**: 经验积累，越用越快越准
4. **灵活性**: 支持单次任务和无限循环任务

**核心价值**:
- 用户只需描述任务，系统自主完成
- 遇到问题自动恢复，无需人工干预
- 随着使用时间增长，效率持续提升

---

**下一步**: 开始 Phase 1 实现，构建 Master-Worker 协作基础

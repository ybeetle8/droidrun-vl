# 项目工程代码结构规划

> **设计原则**: 模块化、可扩展、职责清晰、易于测试

**文档版本**: v1.0
**创建时间**: 2025-11-01
**类型**: 工程架构设计

---

## 一、整体目录结构

```
droidrun-vl/
│
├── src/                          # 核心源代码
│   ├── agents/                   # Agent 层 (双层架构)
│   │   ├── __init__.py
│   │   ├── master/               # Master Agent (任务管理层)
│   │   │   ├── __init__.py
│   │   │   ├── task_manager.py   # 任务分解与调度
│   │   │   ├── supervisor.py     # 执行监督
│   │   │   ├── recovery.py       # 异常恢复策略
│   │   │   └── loop_scheduler.py # 循环任务调度器
│   │   │
│   │   ├── worker/               # Worker Agent (执行层)
│   │   │   ├── __init__.py
│   │   │   ├── executor.py       # 主执行循环
│   │   │   ├── observer.py       # 屏幕观察模块
│   │   │   ├── decision_maker.py # 决策生成
│   │   │   └── action_runner.py  # 动作执行器
│   │   │
│   │   ├── state.py              # 状态管理 (TypedDict)
│   │   └── nodes.py              # LangGraph 节点定义
│   │
│   ├── memory/                   # 记忆系统
│   │   ├── __init__.py
│   │   ├── working_memory.py     # 工作记忆 (短期, deque)
│   │   ├── long_term_memory.py   # 长期记忆管理器
│   │   ├── vector_store.py       # 向量存储接口 (LanceDB/ChromaDB)
│   │   ├── experience.py         # 经验记录模型
│   │   └── retriever.py          # 经验检索器
│   │
│   ├── tools/                    # 工具层
│   │   ├── __init__.py
│   │   ├── android.py            # Android ADB 操作工具
│   │   ├── vision.py             # 视觉分析工具 (VL 模型)
│   │   ├── ui_detector.py        # UI 元素检测 (a11y_tree)
│   │   ├── action_executor.py    # 底层动作执行 (tap/swipe/input)
│   │   └── file.py               # 文件操作工具
│   │
│   │
│   ├── models/                   # 数据模型
│   │   ├── __init__.py
│   │   ├── schemas.py            # Pydantic 基础模型
│   │   ├── task_models.py        # 任务相关模型
│   │   ├── action_models.py      # 操作动作模型
│   │   └── memory_models.py      # 记忆数据模型
│   │
│   ├── utils/                    # 工具函数
│   │   ├── __init__.py
│   │   ├── config.py             # 配置管理
│   │   ├── logger.py             # 日志工具
│   │   ├── ui_processor.py       # UI 界面处理
│   │   ├── pattern_matcher.py    # 模式匹配 (循环检测)
│   │   └── helpers.py            # 通用辅助函数
│   │
│   ├── llm/                      # LLM 集成层
│   │   ├── __init__.py
│   │   ├── client.py             # LLM 客户端封装
│   │   ├── prompts/              # Prompt 模板
│   │   │   ├── master_prompts.py
│   │   │   ├── worker_prompts.py
│   │   │   └── analysis_prompts.py
│   │   └── parsers.py            # 输出解析器
│   │
│   └── main.py                   # 程序入口
│
├── test/                         # 测试目录
│   ├── unit/                     # 单元测试
│   │   ├── test_memory.py
│   │   ├── test_tools.py
│   │   └── test_decision_maker.py
│   ├── integration/              # 集成测试
│   │   ├── test_master_worker.py
│   │   └── test_full_workflow.py
│   └── fixtures/                 # 测试数据
│       ├── screenshots/
│       └── mock_data.json
│
├── data/                         # 数据存储
│   ├── experiences/              # 经验库
│   │   ├── vector_db/            # 向量数据库文件
│   │   └── metadata.db           # SQLite 元数据
│   ├── screenshots/              # 运行时截图
│   └── logs/                     # 执行日志
│
├── configs/                      # 配置文件
│   ├── default.yaml              # 默认配置
│   ├── llm_config.yaml           # LLM 配置
│   └── device_config.yaml        # 设备配置
│
├── notes/                        # 文档
│   ├── 架构设计文档.md
│   └── 技术实现细节.md
│
├── pyproject.toml                # 项目配置
├── uv.lock                       # 依赖锁定文件
├── README.md
└── CLAUDE.md                     # Claude 指令文件
```

---

## 二、核心模块设计

### 2.1 agents/ - Agent 层

#### 职责分离原则

**Master Agent (master/)**
- **任务管理**: 接收用户任务并分解为子任务
- **监督执行**: 实时监控 Worker 的执行状态
- **异常恢复**: 检测异常并执行恢复策略
- **循环调度**: 管理无限循环任务

**Worker Agent (worker/)**
- **观察决策**: 屏幕观察 → 思考 → 生成操作
- **动作执行**: 执行具体点击/滑动/输入
- **即时反馈**: 判断操作结果并纠错
- **状态报告**: 向 Master 汇报执行进度

#### 关键文件

```python
# agents/master/task_manager.py
class TaskManager:
    """任务分解与调度"""
    def decompose_task(self, user_task: str) -> list[SubTask]
    def schedule_next(self) -> SubTask | None
    def is_loop_task(self) -> bool

# agents/worker/executor.py
class WorkerExecutor:
    """Worker 主循环: 观察→思考→决策→执行→反馈"""
    def run(self, sub_task: SubTask) -> ExecutionResult
    def observe(self) -> ScreenState
    def decide(self, state: ScreenState) -> Action
    def execute(self, action: Action) -> ActionResult
```

---

### 2.2 memory/ - 记忆系统

#### 双层记忆架构

**工作记忆 (Working Memory)**
- 短期缓存最近 7±2 步操作
- 用于循环检测和上下文保持
- 数据结构: `collections.deque`

**长期记忆 (Long-term Memory)**
- 存储成功的操作经验
- 向量检索 + 元数据查询
- 自动淘汰低成功率经验

#### 核心接口

```python
# memory/long_term_memory.py
class LongTermMemory:
    def store_experience(self, task: str, actions: list[Action], success: bool)
    def retrieve_similar(self, task: str, top_k: int = 3) -> list[Experience]
    def update_success_rate(self, exp_id: str, success: bool)

# memory/vector_store.py
class VectorStore:
    """抽象接口, 支持 LanceDB/ChromaDB 切换"""
    def add(self, text: str, metadata: dict) -> str
    def search(self, query: str, top_k: int) -> list[dict]
```

---

### 2.3 tools/ - 工具层

#### 工具分类

**设备交互工具**
- `android.py`: ADB 封装 (基于 droidrun)
- `action_executor.py`: 底层动作执行

**视觉感知工具**
- `vision.py`: VL 模型调用 (Qwen3-VL-4B)
- `ui_detector.py`: UI 元素检测 (get_state → a11y_tree)

#### 设计原则

```python
# tools/android.py
class AndroidTools:
    """所有 Android 操作的统一入口"""
    def tap(self, x: int, y: int) -> bool
    def swipe(self, start: tuple, end: tuple, duration: int = 300) -> bool
    def input_text(self, text: str) -> bool
    def get_screenshot(self) -> bytes
    def get_ui_tree(self) -> dict  # a11y_tree

# tools/vision.py
class VisionAnalyzer:
    """屏幕语义理解"""
    def analyze_screen(self, image: bytes, prompt: str) -> str
    def locate_element(self, image: bytes, description: str) -> tuple[int, int]
```

---

### 2.4 graph/ - LangGraph 工作流

#### 双图设计

**Master Graph**
```python
# graph/master_graph.py
"""
节点:
- decompose_task: 分解任务
- assign_to_worker: 分配给 Worker
- monitor_execution: 监控执行
- handle_exception: 异常处理
- check_completion: 完成判定
- schedule_loop: 循环调度

边:
- 正常流程: decompose → assign → monitor → check_completion
- 异常流程: monitor → handle_exception → assign (重试)
- 循环流程: check_completion → schedule_loop → assign
"""

# graph/worker_graph.py
"""
节点:
- observe: 截屏 + 视觉分析
- think: 思考当前状态
- decide: 生成操作决策
- execute: 执行动作
- verify: 验证结果
- report: 报告给 Master

边:
- 主循环: observe → think → decide → execute → verify
- 失败重试: verify → think (重新思考)
- 完成退出: verify → report
"""
```

#### 状态共享

```python
# agents/state.py
class MasterState(TypedDict):
    user_task: str
    sub_tasks: list[SubTask]
    current_task_index: int
    worker_status: str
    exception_count: int
    is_loop: bool

class WorkerState(TypedDict):
    sub_task: SubTask
    screen_image: bytes
    ui_tree: dict
    working_memory: deque[Action]
    current_decision: Action
    execution_result: ActionResult
```

---

### 2.5 models/ - 数据模型

#### Pydantic 模型定义

```python
# models/task_models.py
class SubTask(BaseModel):
    """子任务"""
    id: str
    description: str
    target_state: str  # 目标状态描述
    max_steps: int = 20
    timeout: int = 60

# models/action_models.py
class Action(BaseModel):
    """操作动作"""
    type: Literal["tap", "swipe", "input", "back", "wait"]
    params: dict  # {"x": 100, "y": 200} 或 {"text": "hello"}
    reasoning: str  # 为什么做这个操作

# models/memory_models.py
class Experience(BaseModel):
    """经验记录"""
    id: str
    task_description: str
    actions: list[Action]
    success: bool
    success_rate: float
    use_count: int
    created_at: datetime
    last_used_at: datetime
```

---

### 2.6 llm/ - LLM 集成层

#### Prompt 管理

```python
# llm/prompts/worker_prompts.py
OBSERVE_PROMPT = """
你正在执行任务: {task_description}

当前屏幕截图:
{screenshot}

UI 元素树:
{ui_tree}

工作记忆 (最近操作):
{working_memory}

请分析:
1. 当前在哪个页面?
2. 距离目标还差什么?
3. 是否出现异常?
"""

DECIDE_PROMPT = """
基于当前观察:
{observation}

目标: {target}

生成 3 个候选操作并评估:
1. 操作描述
2. 成功概率
3. 风险评估
4. 推荐理由

最终选择最佳操作并输出 JSON:
{
  "type": "tap",
  "params": {"x": 100, "y": 200},
  "reasoning": "..."
}
"""
```

---

## 三、数据流设计

### 3.1 Master-Worker 交互流程

```
用户输入 "到闲鱼购买硬盘"
        ↓
[Master] 任务分解
        ├─ 子任务1: 打开闲鱼
        ├─ 子任务2: 搜索硬盘
        └─ 子任务3: 筛选并购买
        ↓
[Master] 分配子任务1 → [Worker]
        ↓
[Worker] 执行循环:
        ├─ 观察屏幕
        ├─ 决策: 点击闲鱼图标
        ├─ 执行动作
        └─ 反馈: 成功打开
        ↓
[Worker] 报告 → [Master]
        ↓
[Master] 验证完成 → 分配子任务2
        ↓
... (循环继续)
```

### 3.2 异常恢复流程

```
[Worker] 执行失败 (误触退出 App)
        ↓
[Worker] 报告异常 → [Master]
        ↓
[Master] 检测到异常:
        ├─ 当前状态: 不在闲鱼
        ├─ 预期状态: 闲鱼搜索页
        └─ 判断: 任务未完成
        ↓
[Master] 执行恢复策略:
        ├─ Level 1: 重新打开闲鱼
        ├─ Level 2: 导航到搜索页
        └─ 继续子任务2
        ↓
[Worker] 重新执行 → 成功
```

---

## 四、技术选型与依赖

### 4.1 核心依赖

```toml
[dependencies]
# Agent 框架
langgraph = ">=0.2.0"
langchain = ">=0.3.0"

# 向量检索
lancedb = ">=0.25.2"        # 轻量级向量数据库
# chromadb = ">=0.5.0"      # 备选方案

# Android 控制
adbutils = ">=2.10.2"
droidrun = ">=0.3.9"

# LLM 集成
llama-index = ">=0.14.4"
openai = ">=1.99.1"         # API 客户端

# 数据模型
pydantic = ">=2.11.10"

# 工具
rich = ">=14.1.0"           # 终端美化
loguru = ">=0.7.0"          # 日志
pyyaml = ">=6.0"            # 配置文件
```

### 4.2 可选依赖

```toml
[project.optional-dependencies]
# VL 模型
vision = [
    "transformers>=4.50.0",
    "torch>=2.5.0",
]

# 开发工具
dev = [
    "pytest>=8.0.0",
    "pytest-asyncio>=0.25.0",
    "black>=23.0.0",
    "ruff>=0.13.0",
]
```

---

## 五、配置管理

### 5.1 配置文件结构

```yaml
# configs/default.yaml
app:
  name: "DroidRun-VL"
  version: "0.1.0"

llm:
  provider: "openai"  # openai/anthropic/google
  model: "gpt-4o"
  temperature: 0.7
  max_tokens: 2000

vision:
  model: "Qwen/Qwen3-VL-4B"
  device: "cuda"  # cuda/cpu

memory:
  vector_store: "lancedb"  # lancedb/chromadb
  db_path: "data/experiences/vector_db"
  max_working_memory: 7
  experience_retention_days: 90

device:
  adb_host: "127.0.0.1"
  adb_port: 5037
  device_serial: null  # auto-detect
  screenshot_format: "png"

agent:
  master:
    max_retries: 3
    exception_timeout: 30
  worker:
    max_steps_per_task: 20
    action_wait_time: 0.5
    loop_detection_threshold: 3
```

### 5.2 配置加载

```python
# utils/config.py
from pydantic_settings import BaseSettings

class AppConfig(BaseSettings):
    class Config:
        yaml_file = "configs/default.yaml"

    @classmethod
    def load(cls, config_path: str = None) -> "AppConfig":
        # 加载 YAML + 环境变量覆盖
        ...

config = AppConfig.load()
```

---

## 六、日志与监控

### 6.1 日志分级

```python
# utils/logger.py
from loguru import logger

logger.add(
    "data/logs/master_{time}.log",
    rotation="1 day",
    retention="7 days",
    level="INFO",
    filter=lambda record: "master" in record["extra"]
)

logger.add(
    "data/logs/worker_{time}.log",
    rotation="1 day",
    level="DEBUG",
    filter=lambda record: "worker" in record["extra"]
)
```

### 6.2 关键日志点

```python
# Master Agent
logger.info("任务分解完成", task=user_task, sub_tasks=len(sub_tasks))
logger.warning("检测到异常", exception=exc, recovery_level=2)

# Worker Agent
logger.debug("观察屏幕", ui_elements=len(ui_tree))
logger.info("执行动作", action=action.type, params=action.params)
logger.error("动作失败", action=action, error=err)
```

---

## 七、测试策略

### 7.1 测试分层

```python
# test/unit/test_memory.py
def test_working_memory_capacity():
    """测试工作记忆容量限制"""
    mem = WorkingMemory(max_size=7)
    for i in range(10):
        mem.add(Action(...))
    assert len(mem) == 7

# test/integration/test_master_worker.py
@pytest.mark.asyncio
async def test_single_task_execution():
    """测试单任务完整执行"""
    master = MasterAgent(...)
    result = await master.run("打开设置")
    assert result.success == True
```

### 7.2 Mock 策略

```python
# test/fixtures/mock_data.json
{
  "screenshots": {
    "home_screen": "test/fixtures/screenshots/home.png",
    "settings": "test/fixtures/screenshots/settings.png"
  },
  "ui_trees": {
    "home_screen": {...}
  }
}
```

---

## 八、部署与运行

### 8.1 开发环境

```bash
# 安装依赖
uv sync

# 运行测试
uv run pytest

# 启动 Master Agent
uv run python src/main.py --task "打开闲鱼"
```

### 8.2 生产环境

```bash
# 构建包
uv build

# 安装
pip install dist/droidrun_vl-0.1.0.tar.gz

# 运行
droidrun-vl --config configs/production.yaml --task "..."
```

---

## 九、扩展性设计

### 9.1 新增 LLM 支持

```python
# llm/client.py
class LLMClient:
    @staticmethod
    def create(provider: str):
        if provider == "openai":
            return OpenAIClient()
        elif provider == "anthropic":
            return AnthropicClient()
        # 新增只需实现统一接口
        elif provider == "custom":
            return CustomLLMClient()
```

### 9.2 新增工具

```python
# tools/custom_tool.py
from tools.base import BaseTool

class CustomTool(BaseTool):
    def execute(self, **kwargs) -> ToolResult:
        # 实现自定义逻辑
        ...
```

---

## 十、实施优先级

### Phase 1: 基础架构 (1-2 周)

```
✅ 目录结构搭建
✅ 基础数据模型定义
✅ 配置管理系统
✅ Android 工具层封装
✅ 简单 Worker Agent (无记忆)
```

### Phase 2: 核心功能 (2-3 周)

```
✅ Master-Worker 协作
✅ LangGraph 工作流
✅ 异常检测与恢复
✅ 工作记忆管理
✅ 基础视觉分析
```

### Phase 3: 记忆系统 (2-3 周)

```
✅ 长期记忆存储
✅ 向量检索实现
✅ 经验学习机制
✅ 模式提取与泛化
```

### Phase 4: 优化与增强 (2-3 周)

```
✅ 循环任务调度
✅ 性能优化
✅ 完整测试覆盖
✅ 文档与示例
```

---

## 十一、关键原则总结

1. **模块化**: 每个模块单一职责，低耦合高内聚
2. **可测试**: 所有核心逻辑都可单元测试
3. **可配置**: 关键参数通过配置文件管理
4. **可扩展**: 抽象接口设计，易于新增功能
5. **可观测**: 完善日志，方便调试和监控
6. **向后兼容**: API 变更遵循语义化版本

---

## 附录: 快速开始示例

```python
# examples/quick_start.py
from src.agents.master.task_manager import TaskManager
from src.graph.master_graph import build_master_graph

# 1. 初始化
task_manager = TaskManager()
graph = build_master_graph()

# 2. 执行任务
result = graph.run({
    "user_task": "打开闲鱼，搜索硬盘",
    "config": {...}
})

# 3. 查看结果
print(result["status"])  # success / failed
print(result["actions"])  # 执行的操作序列
```

---

**下一步**: 根据 Phase 1 计划开始搭建基础架构

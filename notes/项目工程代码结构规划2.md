# é¡¹ç›®å·¥ç¨‹ä»£ç ç»“æ„è§„åˆ’ (è‡ªç ”æ¡†æ¶ç‰ˆ)

> **è®¾è®¡åŸåˆ™**: äººç±»è®¤çŸ¥æ¨¡æ‹Ÿã€å®Œå…¨æ§åˆ¶æµç¨‹ã€å¹¶å‘ä¼˜å…ˆã€çµæ´»å¯æ‰©å±•

**æ–‡æ¡£ç‰ˆæœ¬**: v2.0
**åˆ›å»ºæ—¶é—´**: 2025-11-02
**ç±»å‹**: è‡ªç ”æ¡†æ¶å·¥ç¨‹æ¶æ„è®¾è®¡
**æ ¸å¿ƒç†å¿µ**: æŠ›å¼ƒ LangGraphï¼Œå®Œå…¨è‡ªä¸»æ§åˆ¶è®¤çŸ¥å¾ªç¯

---

## ä¸€ã€ä¸ºä»€ä¹ˆé€‰æ‹©è‡ªç ”æ¡†æ¶ï¼Ÿ

### 1.1 æ ¸å¿ƒéœ€æ±‚åˆ†æ

æœ¬é¡¹ç›®æ˜¯ **äººç±»è®¤çŸ¥æ¨¡æ‹Ÿ**ï¼Œä¸æ˜¯ç®€å•çš„æµç¨‹ç¼–æ’ï¼Œæœ‰ 8 ä¸ªæ ¸å¿ƒéœ€æ±‚ï¼š

| éœ€æ±‚ | LangGraph | è‡ªç ”æ¡†æ¶ | é‡è¦æ€§ |
|------|-----------|---------|--------|
| å¹¶å‘æ„ŸçŸ¥ (OCR+UI+Vision åŒæ—¶æ‰§è¡Œ) | âŒ ä¸²è¡ŒèŠ‚ç‚¹ | âœ… asyncio.gather | **è‡´å‘½** |
| æŒç»­è§‚å¯Ÿ (0.5s é—´éš”åå°ç›‘æ§) | âŒ éš¾ä»¥å®ç° | âœ… create_task | **è‡´å‘½** |
| å³æ—¶åé¦ˆ (æ‰§è¡Œå 0.5s åˆ¤æ–­çº é”™) | âš ï¸ éœ€æ‹†åˆ† 5 ä¸ªèŠ‚ç‚¹ | âœ… ä¸€ä¸ªå‡½æ•°å®Œæˆ | **è‡´å‘½** |
| å·¥ä½œè®°å¿† (7Â±2 å®¹é‡+æ—¶é—´è¡°å‡) | âš ï¸ æ‰‹åŠ¨ç»´æŠ¤ | âœ… ç‹¬ç«‹å¯¹è±¡ | é‡è¦ |
| å…ƒè®¤çŸ¥ç›‘æ§ (é«˜é£é™©å†³ç­–äºŒæ¬¡éªŒè¯) | âŒ éš¾ä»¥å®ç° | âœ… å‡½æ•°å†…è°ƒç”¨ | é‡è¦ |
| åŠ¨æ€é‡è§„åˆ’ (å¡ä½æ—¶æ”¹å˜è·¯å¾„) | âŒ é™æ€å›¾ | âœ… ä»»æ„è·³è½¬ | é‡è¦ |
| å¼‚å¸¸å¤„ç† (å¼¹çª—/åŠ è½½/é”™è¯¯) | âš ï¸ éœ€æ¡ä»¶è¾¹ | âœ… ç›´æ¥å¤„ç† | é‡è¦ |
| CoT å†³ç­– | âœ… å¯ä»¥ | âœ… å¯ä»¥ | ä¸€èˆ¬ |

**ç»“è®º**: 3 ä¸ªè‡´å‘½é™åˆ¶ + 4 ä¸ªä¸¥é‡é—®é¢˜ = LangGraph ä¸é€‚åˆ

### 1.2 è‡ªç ”æ¡†æ¶ä¼˜åŠ¿

âœ… **å®Œå…¨æ§åˆ¶**: æƒ³æ€ä¹ˆå†™å°±æ€ä¹ˆå†™ï¼Œæ²¡æœ‰æ¡†æ¶é™åˆ¶
âœ… **æ€§èƒ½æœ€ä¼˜**: å¹¶å‘æ„ŸçŸ¥é€Ÿåº¦æå‡ 3 å€ï¼ˆ0.5s vs 1.5sï¼‰
âœ… **ä»£ç ç®€æ´**: å³æ—¶åé¦ˆ 1 ä¸ªå‡½æ•°æå®šï¼ˆvs LangGraph 5 ä¸ªèŠ‚ç‚¹ï¼‰
âœ… **çµæ´»æ‰©å±•**: éšæ—¶ä¿®æ”¹æ‰§è¡Œé€»è¾‘ï¼Œæ— éœ€é‡æ„å›¾ç»“æ„
âœ… **æ ¸å¿ƒç«äº‰åŠ›**: ä¸ä¾èµ–å¤–éƒ¨æ¡†æ¶ï¼ŒæŠ€æœ¯å®Œå…¨è‡ªä¸»

---

## äºŒã€æ•´ä½“ç›®å½•ç»“æ„

```
droidrun-vl/
â”‚
â”œâ”€â”€ src/                          # æ ¸å¿ƒæºä»£ç 
â”‚   â”œâ”€â”€ core/                     # æ ¸å¿ƒè®¤çŸ¥å¼•æ“ (è‡ªç ”)
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ master_agent.py       # Master Agent (ä»»åŠ¡ç®¡ç†)
â”‚   â”‚   â”œâ”€â”€ worker_agent.py       # Worker Agent (è®¤çŸ¥æ‰§è¡Œ)
â”‚   â”‚   â”œâ”€â”€ cognitive_loop.py     # è®¤çŸ¥ä¸»å¾ªç¯
â”‚   â”‚   â””â”€â”€ state_manager.py      # çŠ¶æ€ç®¡ç†å™¨
â”‚   â”‚
â”‚   â”œâ”€â”€ perception/               # æ„ŸçŸ¥ç³»ç»Ÿ (å¹¶å‘)
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ vision_analyzer.py    # è§†è§‰åˆ†æ (VL æ¨¡å‹)
â”‚   â”‚   â”œâ”€â”€ ui_detector.py        # UI å…ƒç´ æ£€æµ‹
â”‚   â”‚   â”œâ”€â”€ ocr_extractor.py      # æ–‡æœ¬æå–
â”‚   â”‚   â”œâ”€â”€ screen_observer.py    # æŒç»­è§‚å¯Ÿ (åå°ä»»åŠ¡)
â”‚   â”‚   â””â”€â”€ fusion.py             # å¤šæ¨¡æ€èåˆ
â”‚   â”‚
â”‚   â”œâ”€â”€ decision/                 # å†³ç­–ç³»ç»Ÿ
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ decision_maker.py     # æ ¸å¿ƒå†³ç­–å™¨ (CoT)
â”‚   â”‚   â”œâ”€â”€ metacognition.py      # å…ƒè®¤çŸ¥ç›‘æ§
â”‚   â”‚   â”œâ”€â”€ planner.py            # ä»»åŠ¡è§„åˆ’å™¨
â”‚   â”‚   â””â”€â”€ risk_evaluator.py     # é£é™©è¯„ä¼°
â”‚   â”‚
â”‚   â”œâ”€â”€ execution/                # æ‰§è¡Œç³»ç»Ÿ
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ action_executor.py    # åŠ¨ä½œæ‰§è¡Œ (tap/swipe/input)
â”‚   â”‚   â”œâ”€â”€ feedback_controller.py # å³æ—¶åé¦ˆæ§åˆ¶å™¨
â”‚   â”‚   â”œâ”€â”€ trial_error.py        # è¯•é”™æœºåˆ¶
â”‚   â”‚   â””â”€â”€ recovery.py           # å¼‚å¸¸æ¢å¤
â”‚   â”‚
â”‚   â”œâ”€â”€ memory/                   # è®°å¿†ç³»ç»Ÿ
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ working_memory.py     # å·¥ä½œè®°å¿† (7Â±2, deque)
â”‚   â”‚   â”œâ”€â”€ long_term_memory.py   # é•¿æœŸè®°å¿† (å‘é‡æ•°æ®åº“)
â”‚   â”‚   â”œâ”€â”€ spatial_memory.py     # ç©ºé—´è®°å¿† (é¡µé¢å¯¼èˆªå›¾)
â”‚   â”‚   â”œâ”€â”€ experience_store.py   # ç»éªŒå­˜å‚¨
â”‚   â”‚   â””â”€â”€ retriever.py          # ç»éªŒæ£€ç´¢å™¨
â”‚   â”‚
â”‚   â”œâ”€â”€ device/                   # è®¾å¤‡äº¤äº’å±‚
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ android_controller.py # Android æ§åˆ¶å™¨ (åŸºäº droidrun)
â”‚   â”‚   â”œâ”€â”€ adb_tools.py          # ADB å·¥å…·å°è£…
â”‚   â”‚   â””â”€â”€ screen_capture.py     # æˆªå±å·¥å…·
â”‚   â”‚
â”‚   â”œâ”€â”€ models/                   # æ•°æ®æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ task.py               # ä»»åŠ¡æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ action.py             # åŠ¨ä½œæ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ perception.py         # æ„ŸçŸ¥ç»“æœæ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ decision.py           # å†³ç­–æ¨¡å‹
â”‚   â”‚   â””â”€â”€ experience.py         # ç»éªŒæ¨¡å‹
â”‚   â”‚
â”‚   â”œâ”€â”€ llm/                      # LLM é›†æˆ
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ client.py             # LLM å®¢æˆ·ç«¯ (ç»Ÿä¸€æ¥å£)
â”‚   â”‚   â”œâ”€â”€ prompts/              # Prompt æ¨¡æ¿
â”‚   â”‚   â”‚   â”œâ”€â”€ perception_prompts.py
â”‚   â”‚   â”‚   â”œâ”€â”€ decision_prompts.py
â”‚   â”‚   â”‚   â””â”€â”€ planning_prompts.py
â”‚   â”‚   â””â”€â”€ parsers.py            # è¾“å‡ºè§£æå™¨
â”‚   â”‚
â”‚   â”œâ”€â”€ utils/                    # å·¥å…·å‡½æ•°
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ config.py             # é…ç½®ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ logger.py             # æ—¥å¿—ç³»ç»Ÿ
â”‚   â”‚   â”œâ”€â”€ metrics.py            # æ€§èƒ½æŒ‡æ ‡
â”‚   â”‚   â”œâ”€â”€ visualizer.py         # æ‰§è¡Œå¯è§†åŒ– (Mermaid)
â”‚   â”‚   â””â”€â”€ helpers.py            # è¾…åŠ©å‡½æ•°
â”‚   â”‚
â”‚   â””â”€â”€ main.py                   # ç¨‹åºå…¥å£
â”‚
â”œâ”€â”€ tests/                        # æµ‹è¯•ç›®å½•
â”‚   â”œâ”€â”€ unit/                     # å•å…ƒæµ‹è¯•
â”‚   â”‚   â”œâ”€â”€ test_perception.py
â”‚   â”‚   â”œâ”€â”€ test_decision.py
â”‚   â”‚   â”œâ”€â”€ test_memory.py
â”‚   â”‚   â””â”€â”€ test_execution.py
â”‚   â”œâ”€â”€ integration/              # é›†æˆæµ‹è¯•
â”‚   â”‚   â”œâ”€â”€ test_cognitive_loop.py
â”‚   â”‚   â””â”€â”€ test_end_to_end.py
â”‚   â””â”€â”€ fixtures/                 # æµ‹è¯•æ•°æ®
â”‚       â”œâ”€â”€ screenshots/
â”‚       â””â”€â”€ mock_ui_trees.json
â”‚
â”œâ”€â”€ data/                         # æ•°æ®å­˜å‚¨
â”‚   â”œâ”€â”€ experiences/              # ç»éªŒåº“
â”‚   â”‚   â”œâ”€â”€ vector_db/            # å‘é‡æ•°æ®åº“ (LanceDB)
â”‚   â”‚   â””â”€â”€ metadata.db           # SQLite å…ƒæ•°æ®
â”‚   â”œâ”€â”€ spatial_maps/             # ç©ºé—´è®°å¿† (é¡µé¢å¯¼èˆªå›¾)
â”‚   â”œâ”€â”€ screenshots/              # è¿è¡Œæ—¶æˆªå›¾
â”‚   â””â”€â”€ logs/                     # æ‰§è¡Œæ—¥å¿—
â”‚
â”œâ”€â”€ configs/                      # é…ç½®æ–‡ä»¶
â”‚   â”œâ”€â”€ default.yaml              # é»˜è®¤é…ç½®
â”‚   â”œâ”€â”€ llm.yaml                  # LLM é…ç½®
â”‚   â”œâ”€â”€ perception.yaml           # æ„ŸçŸ¥ç³»ç»Ÿé…ç½®
â”‚   â””â”€â”€ device.yaml               # è®¾å¤‡é…ç½®
â”‚
â”œâ”€â”€ examples/                     # ç¤ºä¾‹ä»£ç 
â”‚   â”œâ”€â”€ simple_task.py            # ç®€å•ä»»åŠ¡ç¤ºä¾‹
â”‚   â”œâ”€â”€ loop_task.py              # å¾ªç¯ä»»åŠ¡ç¤ºä¾‹
â”‚   â””â”€â”€ recovery_demo.py          # å¼‚å¸¸æ¢å¤æ¼”ç¤º
â”‚
â”œâ”€â”€ docs/                         # æ–‡æ¡£
â”‚   â”œâ”€â”€ architecture.md           # æ¶æ„è®¾è®¡
â”‚   â”œâ”€â”€ api_reference.md          # API å‚è€ƒ
â”‚   â””â”€â”€ development_guide.md      # å¼€å‘æŒ‡å—
â”‚
â”œâ”€â”€ pyproject.toml                # é¡¹ç›®é…ç½®
â”œâ”€â”€ uv.lock                       # ä¾èµ–é”å®š
â”œâ”€â”€ README.md
â””â”€â”€ CLAUDE.md                     # Claude æŒ‡ä»¤
```

---

## ä¸‰ã€æ ¸å¿ƒæ¨¡å—è¯¦ç»†è®¾è®¡

### 3.1 core/ - æ ¸å¿ƒè®¤çŸ¥å¼•æ“

è¿™æ˜¯æ•´ä¸ªç³»ç»Ÿçš„"å¤§è„‘"ï¼Œå®ç°åŒå±‚ Agent æ¶æ„ã€‚

#### 3.1.1 MasterAgent - ä»»åŠ¡ç®¡ç†å±‚

```python
# core/master_agent.py
from typing import List, Optional
from ..models.task import Task, SubTask
from .worker_agent import WorkerAgent
from .state_manager import StateManager
from ..execution.recovery import RecoveryController

class MasterAgent:
    """
    Master Agent - ä»»åŠ¡ç®¡ç†å±‚

    èŒè´£:
    - ä»»åŠ¡åˆ†è§£ä¸è°ƒåº¦
    - Worker æ‰§è¡Œç›‘ç£
    - å¼‚å¸¸æ£€æµ‹ä¸æ¢å¤
    - å¾ªç¯ä»»åŠ¡ç®¡ç†
    """

    def __init__(
        self,
        worker: WorkerAgent,
        state_manager: StateManager,
        recovery: RecoveryController
    ):
        self.worker = worker
        self.state = state_manager
        self.recovery = recovery
        self.current_task: Optional[Task] = None

    async def execute_task(self, task: Task) -> ExecutionResult:
        """
        æ‰§è¡Œç”¨æˆ·ä»»åŠ¡

        Args:
            task: ç”¨æˆ·ä»»åŠ¡ (å¦‚: "åˆ°é—²é±¼è´­ä¹° 1TB ç¡¬ç›˜")

        Returns:
            æ‰§è¡Œç»“æœ
        """
        self.current_task = task

        # 1. ä»»åŠ¡åˆ†è§£
        sub_tasks = await self._decompose_task(task)
        logger.info(f"ä»»åŠ¡åˆ†è§£å®Œæˆ: {len(sub_tasks)} ä¸ªå­ä»»åŠ¡")

        # 2. å¾ªç¯æ‰§è¡Œå­ä»»åŠ¡
        for idx, sub_task in enumerate(sub_tasks):
            logger.info(f"æ‰§è¡Œå­ä»»åŠ¡ {idx+1}/{len(sub_tasks)}: {sub_task.description}")

            # åˆ†é…ç»™ Worker
            result = await self._execute_with_supervision(sub_task)

            if result.status == "failed":
                # å¼‚å¸¸æ¢å¤
                recovered = await self.recovery.recover(sub_task, result.error)
                if not recovered:
                    return ExecutionResult(status="failed", error=result.error)

            # åˆ¤æ–­æ˜¯å¦å®Œæˆ
            if self._is_task_complete(task, idx):
                logger.info("ä»»åŠ¡å®Œæˆï¼")
                return ExecutionResult(status="success")

        return ExecutionResult(status="success")

    async def _execute_with_supervision(self, sub_task: SubTask) -> ExecutionResult:
        """
        ç›‘ç£ Worker æ‰§è¡Œå­ä»»åŠ¡

        ç›‘ç£å†…å®¹:
        - æ‰§è¡Œè¿›åº¦ç›‘æ§
        - å¡æ­»/å¾ªç¯æ£€æµ‹
        - å¼‚å¸¸æ•è·
        """
        # å¯åŠ¨ç›‘ç£ä»»åŠ¡
        supervisor_task = asyncio.create_task(self._supervise_worker())

        try:
            # Worker æ‰§è¡Œ
            result = await self.worker.execute_sub_task(sub_task)
            return result
        finally:
            supervisor_task.cancel()

    async def _supervise_worker(self):
        """åå°ç›‘ç£ Worker"""
        while True:
            await asyncio.sleep(2)  # æ¯ 2 ç§’æ£€æŸ¥ä¸€æ¬¡

            # æ£€æŸ¥æ˜¯å¦å¡æ­»
            if self.worker.is_stuck():
                logger.warning("Worker å¡æ­»ï¼Œè§¦å‘å¹²é¢„")
                await self.worker.interrupt()

            # æ£€æŸ¥æ˜¯å¦å¾ªç¯
            if self.worker.is_looping():
                logger.warning("æ£€æµ‹åˆ°å¾ªç¯æ“ä½œï¼Œè§¦å‘é‡è§„åˆ’")
                await self.worker.replan()

    async def _decompose_task(self, task: Task) -> List[SubTask]:
        """ä»»åŠ¡åˆ†è§£ (è°ƒç”¨ LLM)"""
        prompt = f"å°†ä»»åŠ¡åˆ†è§£ä¸ºå­ä»»åŠ¡: {task.description}"
        response = await self.llm.generate(prompt)
        return parse_sub_tasks(response)

    def _is_task_complete(self, task: Task, current_idx: int) -> bool:
        """åˆ¤æ–­ä»»åŠ¡æ˜¯å¦å®Œæˆ"""
        # åŸºäºå¤šé‡è¯æ®åˆ¤æ–­
        # 1. æ‰€æœ‰å­ä»»åŠ¡å®Œæˆ
        # 2. ç›®æ ‡çŠ¶æ€è¾¾æˆ
        # 3. Worker ç¡®è®¤å®Œæˆ
        pass
```

#### 3.1.2 WorkerAgent - è®¤çŸ¥æ‰§è¡Œå±‚

```python
# core/worker_agent.py
from ..perception.fusion import PerceptionFusion
from ..decision.decision_maker import DecisionMaker
from ..execution.action_executor import ActionExecutor
from ..execution.feedback_controller import FeedbackController
from ..memory.working_memory import WorkingMemory

class WorkerAgent:
    """
    Worker Agent - è®¤çŸ¥æ‰§è¡Œå±‚

    èŒè´£:
    - è§‚å¯Ÿå±å¹• (å¹¶å‘æ„ŸçŸ¥)
    - å†³ç­–æ“ä½œ (CoT + å…ƒè®¤çŸ¥)
    - æ‰§è¡ŒåŠ¨ä½œ (å³æ—¶åé¦ˆ)
    - è®°å¿†ç®¡ç†
    """

    def __init__(
        self,
        perception: PerceptionFusion,
        decision_maker: DecisionMaker,
        executor: ActionExecutor,
        feedback: FeedbackController,
        working_memory: WorkingMemory
    ):
        self.perception = perception
        self.decision = decision_maker
        self.executor = executor
        self.feedback = feedback
        self.memory = working_memory

    async def execute_sub_task(self, sub_task: SubTask) -> ExecutionResult:
        """
        æ‰§è¡Œå­ä»»åŠ¡ (å®Œæ•´çš„è®¤çŸ¥å¾ªç¯)

        å¾ªç¯: è§‚å¯Ÿ â†’ æ€è€ƒ â†’ å†³ç­– â†’ æ‰§è¡Œ â†’ åé¦ˆ
        """
        logger.info(f"Worker å¼€å§‹æ‰§è¡Œ: {sub_task.description}")

        # å¯åŠ¨åå°æŒç»­è§‚å¯Ÿ
        observer_task = asyncio.create_task(self._continuous_observe())

        try:
            for step in range(sub_task.max_steps):
                # 1. è§‚å¯Ÿ (å¹¶å‘æ„ŸçŸ¥)
                perception = await self.perception.perceive()

                # 2. æ£€æµ‹å¼‚å¸¸
                if self.memory.detect_loop():
                    logger.warning("æ£€æµ‹åˆ°å¾ªç¯æ“ä½œ")
                    await self._break_loop()
                    continue

                # 3. å†³ç­– (å«å…ƒè®¤çŸ¥)
                action = await self.decision.decide(
                    perception=perception,
                    sub_task=sub_task,
                    working_memory=self.memory
                )

                # 4. æ‰§è¡Œ + å³æ—¶åé¦ˆ
                result = await self.feedback.execute_with_feedback(action)

                # 5. æ›´æ–°è®°å¿†
                self.memory.add(action, result)

                # 6. åˆ¤æ–­å®Œæˆ
                if self._is_sub_task_complete(sub_task, perception):
                    logger.info("å­ä»»åŠ¡å®Œæˆ")
                    return ExecutionResult(status="success")

            return ExecutionResult(status="timeout")

        finally:
            observer_task.cancel()

    async def _continuous_observe(self):
        """
        æŒç»­è§‚å¯Ÿ (åå°ä»»åŠ¡)

        èŒè´£:
        - æ£€æµ‹å¼¹çª— â†’ è‡ªåŠ¨å…³é—­
        - æ£€æµ‹åŠ è½½ â†’ ç­‰å¾…
        - æ£€æµ‹é”™è¯¯ â†’ è§¦å‘æ¢å¤
        """
        while True:
            try:
                screenshot = await self.device.screenshot()
                events = await self._detect_events(screenshot)

                if events.popup:
                    logger.info("æ£€æµ‹åˆ°å¼¹çª—ï¼Œè‡ªåŠ¨å…³é—­")
                    await self.device.press_back()

                if events.loading:
                    logger.debug("é¡µé¢åŠ è½½ä¸­...")

                if events.error:
                    logger.error(f"æ£€æµ‹åˆ°é”™è¯¯: {events.error}")
                    await self._handle_error(events.error)

                await asyncio.sleep(0.5)  # 0.5 ç§’é—´éš”

            except asyncio.CancelledError:
                break

    async def _break_loop(self):
        """æ‰“ç ´å¾ªç¯æ“ä½œ"""
        logger.info("å°è¯•æ‰“ç ´å¾ªç¯...")
        # ç­–ç•¥: è¿”å›ä¸Šä¸€é¡µæˆ–å°è¯•å…¶ä»–è·¯å¾„
        await self.device.press_back()
        await asyncio.sleep(1)
```

#### 3.1.3 CognitiveLoop - è®¤çŸ¥ä¸»å¾ªç¯

```python
# core/cognitive_loop.py

class CognitiveLoop:
    """
    è®¤çŸ¥ä¸»å¾ªç¯ - è§‚å¯Ÿâ†’æ€è€ƒâ†’å†³ç­–â†’æ‰§è¡Œâ†’åé¦ˆ

    è¿™æ˜¯ Worker Agent çš„æ ¸å¿ƒæ‰§è¡Œå¼•æ“
    """

    async def run(
        self,
        sub_task: SubTask,
        max_steps: int = 20
    ) -> ExecutionResult:
        """
        æ‰§è¡Œä¸€ä¸ªå®Œæ•´çš„è®¤çŸ¥å¾ªç¯

        ä¼˜åŠ¿:
        - å®Œå…¨è‡ªä¸»æ§åˆ¶æµç¨‹
        - æ”¯æŒå¹¶å‘ã€åå°ä»»åŠ¡
        - å³æ—¶åé¦ˆå’Œçº é”™
        """

        for step in range(max_steps):
            # === è§‚å¯Ÿé˜¶æ®µ ===
            perception = await self._observe()

            # === æ€è€ƒé˜¶æ®µ ===
            context = self._reflect(perception)

            # === å†³ç­–é˜¶æ®µ ===
            action = await self._decide(context)

            # === æ‰§è¡Œé˜¶æ®µ ===
            result = await self._execute(action)

            # === åé¦ˆé˜¶æ®µ ===
            if result.success:
                self._update_memory(action, result)
                if self._is_goal_reached(sub_task):
                    return ExecutionResult(status="success")
            else:
                # å³æ—¶çº é”™
                await self._correct_error(result)

        return ExecutionResult(status="timeout")
```

---

### 3.2 perception/ - æ„ŸçŸ¥ç³»ç»Ÿ (å¹¶å‘)

è¿™æ˜¯ Worker çš„"çœ¼ç›"ï¼Œè´Ÿè´£ç†è§£å±å¹•å†…å®¹ã€‚

#### 3.2.1 æ ¸å¿ƒè®¾è®¡

```python
# perception/fusion.py
from .vision_analyzer import VisionAnalyzer
from .ui_detector import UIDetector
from .ocr_extractor import OCRExtractor

class PerceptionFusion:
    """
    å¤šæ¨¡æ€æ„ŸçŸ¥èåˆå™¨

    æ ¸å¿ƒèƒ½åŠ›: å¹¶å‘æ‰§è¡Œå¤šä¸ªæ„ŸçŸ¥ä»»åŠ¡
    """

    def __init__(
        self,
        vision: VisionAnalyzer,
        ui: UIDetector,
        ocr: OCRExtractor
    ):
        self.vision = vision
        self.ui = ui
        self.ocr = ocr

    async def perceive(self, screenshot: bytes) -> Perception:
        """
        å¹¶å‘æ„ŸçŸ¥ - æ ¸å¿ƒä¼˜åŠ¿ï¼

        LangGraph: 1.5ç§’ (ä¸²è¡Œ)
        è‡ªç ”æ¡†æ¶: 0.5ç§’ (å¹¶è¡Œ)
        """
        # å¹¶å‘æ‰§è¡Œ 3 ä¸ªæ„ŸçŸ¥ä»»åŠ¡
        vision_result, ui_result, ocr_result = await asyncio.gather(
            self.vision.analyze(screenshot),   # è§†è§‰ç†è§£
            self.ui.detect(screenshot),        # UI æ£€æµ‹
            self.ocr.extract(screenshot)       # æ–‡æœ¬æå–
        )

        # èåˆç»“æœ
        return Perception(
            visual=vision_result,
            ui_elements=ui_result,
            text=ocr_result,
            timestamp=time.time()
        )
```

#### 3.2.2 æŒç»­è§‚å¯Ÿå™¨

```python
# perception/screen_observer.py

class ScreenObserver:
    """
    æŒç»­è§‚å¯Ÿå™¨ (åå°ä»»åŠ¡)

    èŒè´£:
    - 0.5 ç§’é—´éš”ç›‘æ§å±å¹•
    - æ£€æµ‹å¼¹çª—/åŠ è½½/é”™è¯¯
    - è‡ªåŠ¨å¤„ç†å¸¸è§å¼‚å¸¸
    """

    def __init__(self, device, event_handler):
        self.device = device
        self.handler = event_handler
        self.running = False

    async def start(self):
        """å¯åŠ¨æŒç»­è§‚å¯Ÿ"""
        self.running = True

        while self.running:
            try:
                # æˆªå±
                screenshot = await self.device.screenshot()

                # æ£€æµ‹äº‹ä»¶
                events = await self._detect_events(screenshot)

                # å¤„ç†äº‹ä»¶
                for event in events:
                    await self.handler.handle(event)

                await asyncio.sleep(0.5)

            except Exception as e:
                logger.error(f"è§‚å¯Ÿå™¨é”™è¯¯: {e}")

    def stop(self):
        """åœæ­¢è§‚å¯Ÿ"""
        self.running = False
```

---

### 3.3 decision/ - å†³ç­–ç³»ç»Ÿ

è¿™æ˜¯ Worker çš„"å¤§è„‘"ï¼Œè´Ÿè´£æ€è€ƒå’Œå†³ç­–ã€‚

#### 3.3.1 å†³ç­–ç”Ÿæˆå™¨

```python
# decision/decision_maker.py

class DecisionMaker:
    """
    å†³ç­–ç”Ÿæˆå™¨

    æ ¸å¿ƒèƒ½åŠ›:
    - CoT æ¨ç†
    - å…ƒè®¤çŸ¥ç›‘æ§
    - å¤šæ–¹æ¡ˆè¯„ä¼°
    """

    async def decide(
        self,
        perception: Perception,
        sub_task: SubTask,
        working_memory: WorkingMemory
    ) -> Action:
        """
        ç”Ÿæˆæ“ä½œå†³ç­–

        æµç¨‹:
        1. CoT æ¨ç† â†’ ç”Ÿæˆ 3 ä¸ªå€™é€‰æ–¹æ¡ˆ
        2. è¯„ä¼°æ¯ä¸ªæ–¹æ¡ˆ (æˆåŠŸç‡ã€é£é™©)
        3. é€‰æ‹©æœ€ä½³æ–¹æ¡ˆ
        4. å…ƒè®¤çŸ¥éªŒè¯ (é«˜é£é™©æ—¶)
        """

        # 1. ç”Ÿæˆå€™é€‰æ–¹æ¡ˆ
        candidates = await self._generate_candidates(
            perception, sub_task, working_memory
        )

        # 2. è¯„ä¼°æ–¹æ¡ˆ
        evaluated = [
            await self._evaluate_action(c, perception)
            for c in candidates
        ]

        # 3. é€‰æ‹©æœ€ä½³
        best_action = max(evaluated, key=lambda x: x.score)

        # 4. å…ƒè®¤çŸ¥éªŒè¯ (é«˜é£é™©æ—¶)
        if best_action.risk > 0.7:
            verified = await self._metacognition_verify(best_action)
            if not verified:
                return await self._rethink(perception, sub_task)

        return best_action

    async def _metacognition_verify(self, action: Action) -> bool:
        """
        å…ƒè®¤çŸ¥éªŒè¯ - äºŒæ¬¡æ€è€ƒ

        é—®è‡ªå·±: "è¿™ä¸ªæ“ä½œçœŸçš„åˆé€‚å—?"
        """
        prompt = f"""
        æˆ‘å‡†å¤‡æ‰§è¡Œ: {action.description}
        é£é™©è¯„ä¼°: {action.risk}

        è¯·éªŒè¯è¿™ä¸ªå†³ç­–æ˜¯å¦æ­£ç¡®ã€‚
        å¦‚æœæœ‰æ›´å¥½çš„æ–¹æ¡ˆï¼Œè¯·æå‡ºã€‚
        """

        response = await self.llm.generate(prompt)
        return "æ­£ç¡®" in response or "åˆé€‚" in response
```

---

### 3.4 execution/ - æ‰§è¡Œç³»ç»Ÿ

è¿™æ˜¯ Worker çš„"æ‰‹"ï¼Œè´Ÿè´£æ‰§è¡ŒåŠ¨ä½œã€‚

#### 3.4.1 å³æ—¶åé¦ˆæ§åˆ¶å™¨

```python
# execution/feedback_controller.py

class FeedbackController:
    """
    å³æ—¶åé¦ˆæ§åˆ¶å™¨

    æ ¸å¿ƒèƒ½åŠ›: æ‰§è¡Œå 0.5 ç§’åˆ¤æ–­ç»“æœå¹¶çº é”™
    """

    def __init__(self, device, executor):
        self.device = device
        self.executor = executor

    async def execute_with_feedback(self, action: Action) -> ActionResult:
        """
        æ‰§è¡ŒåŠ¨ä½œ + å³æ—¶åé¦ˆ

        è¿™æ˜¯è‡ªç ”æ¡†æ¶çš„æ ¸å¿ƒä¼˜åŠ¿ï¼
        LangGraph éœ€è¦ 5 ä¸ªèŠ‚ç‚¹ï¼Œæˆ‘ä»¬ 1 ä¸ªå‡½æ•°æå®š
        """

        # 1. æ‰§è¡Œå‰æˆªå›¾
        screenshot_before = await self.device.screenshot()

        # 2. æ‰§è¡ŒåŠ¨ä½œ
        await self.executor.execute(action)

        # 3. ç­‰å¾…ååº”
        await asyncio.sleep(0.5)

        # 4. æ‰§è¡Œåæˆªå›¾
        screenshot_after = await self.device.screenshot()

        # 5. å³æ—¶åˆ¤æ–­
        judgment = await self._judge_result(
            action,
            screenshot_before,
            screenshot_after
        )

        # 6. çº é”™ (å¦‚æœå¤±è´¥)
        if judgment.status == "failed":
            logger.warning(f"æ“ä½œå¤±è´¥: {judgment.reason}")
            await self.device.press_back()  # ç«‹å³çº é”™
            return ActionResult(success=False, error=judgment.reason)

        return ActionResult(success=True)

    async def _judge_result(
        self,
        action: Action,
        before: bytes,
        after: bytes
    ) -> Judgment:
        """
        åˆ¤æ–­æ“ä½œç»“æœ

        æ–¹æ³•:
        - æ¯”è¾ƒå‰åæˆªå›¾å·®å¼‚
        - æ£€æµ‹ç›®æ ‡ UI æ˜¯å¦å‡ºç°
        - LLM è¯­ä¹‰åˆ¤æ–­
        """

        # æ–¹æ³•1: è§†è§‰å·®å¼‚
        diff_score = compute_image_diff(before, after)
        if diff_score < 0.05:
            return Judgment(status="failed", reason="é¡µé¢æ— å˜åŒ–")

        # æ–¹æ³•2: ç›®æ ‡æ£€æµ‹
        if action.expected_ui:
            found = await detect_ui_element(after, action.expected_ui)
            if not found:
                return Judgment(status="failed", reason="ç›®æ ‡UIæœªå‡ºç°")

        # æ–¹æ³•3: LLM åˆ¤æ–­
        prompt = f"åˆ¤æ–­æ“ä½œæ˜¯å¦æˆåŠŸ: {action.description}"
        result = await self.llm.analyze(after, prompt)

        return Judgment(status="success" if "æˆåŠŸ" in result else "failed")
```

---

### 3.5 memory/ - è®°å¿†ç³»ç»Ÿ

#### 3.5.1 å·¥ä½œè®°å¿†

```python
# memory/working_memory.py
from collections import deque

class WorkingMemory:
    """
    å·¥ä½œè®°å¿† - çŸ­æœŸè®°å¿† (7Â±2 å®¹é‡)

    åŠŸèƒ½:
    - ä¿ç•™æœ€è¿‘æ“ä½œ
    - å¾ªç¯æ£€æµ‹
    - ä¸Šä¸‹æ–‡ä¿æŒ
    """

    def __init__(self, max_size: int = 7):
        self.buffer = deque(maxlen=max_size)
        self.timestamps = deque(maxlen=max_size)

    def add(self, action: Action, result: ActionResult):
        """æ·»åŠ è®°å¿†"""
        memory_item = MemoryItem(
            action=action,
            result=result,
            timestamp=time.time()
        )
        self.buffer.append(memory_item)
        self.timestamps.append(time.time())

    def detect_loop(self) -> bool:
        """
        æ£€æµ‹å¾ªç¯æ“ä½œ

        ç®—æ³•: æ£€æµ‹ A-B-A æˆ– A-A-A æ¨¡å¼
        """
        if len(self.buffer) < 3:
            return False

        # æ£€æŸ¥æœ€è¿‘ 3 æ­¥æ˜¯å¦é‡å¤
        recent_3 = list(self.buffer)[-3:]
        actions = [item.action.type for item in recent_3]

        # A-A-A æ¨¡å¼
        if actions[0] == actions[1] == actions[2]:
            return True

        # A-B-A æ¨¡å¼
        if actions[0] == actions[2]:
            return True

        return False

    def get_context(self, n: int = 5) -> str:
        """
        è·å–ä¸Šä¸‹æ–‡ (æœ€è¿‘ n æ­¥)

        ç”¨äº Prompt æ„å»º
        """
        recent = list(self.buffer)[-n:]
        context = "\n".join([
            f"æ­¥éª¤{i+1}: {item.action.description} â†’ {item.result.status}"
            for i, item in enumerate(recent)
        ])
        return context
```

#### 3.5.2 é•¿æœŸè®°å¿†

```python
# memory/long_term_memory.py
from lancedb import LanceDB

class LongTermMemory:
    """
    é•¿æœŸè®°å¿† - ç»éªŒå­˜å‚¨

    åŠŸèƒ½:
    - å­˜å‚¨æˆåŠŸç»éªŒ
    - å‘é‡æ£€ç´¢
    - æˆåŠŸç‡è¿½è¸ª
    """

    def __init__(self, db_path: str):
        self.db = LanceDB(db_path)
        self.table = self.db.open_table("experiences")

    async def store_experience(
        self,
        task: str,
        actions: List[Action],
        success: bool
    ):
        """å­˜å‚¨ç»éªŒ"""

        experience = Experience(
            id=generate_id(),
            task_description=task,
            actions=actions,
            success=success,
            success_rate=1.0 if success else 0.0,
            use_count=0,
            created_at=datetime.now()
        )

        # ç”Ÿæˆå‘é‡
        embedding = await self._embed(task)

        # å­˜å‚¨
        self.table.add([{
            "id": experience.id,
            "embedding": embedding,
            "metadata": experience.dict()
        }])

    async def retrieve_similar(
        self,
        task: str,
        top_k: int = 3
    ) -> List[Experience]:
        """
        æ£€ç´¢ç›¸ä¼¼ç»éªŒ

        æµç¨‹:
        1. ä»»åŠ¡å‘é‡åŒ–
        2. å‘é‡æœç´¢
        3. æŒ‰æˆåŠŸç‡æ’åº
        """

        query_embedding = await self._embed(task)

        results = self.table.search(query_embedding).limit(top_k).to_list()

        experiences = [
            Experience(**r["metadata"])
            for r in results
            if r["metadata"]["success_rate"] > 0.7  # åªè¿”å›é«˜æˆåŠŸç‡
        ]

        return experiences
```

---

## å››ã€æ ¸å¿ƒä¼˜åŠ¿å¯¹æ¯”

### 4.1 å¹¶å‘æ„ŸçŸ¥ - é€Ÿåº¦æå‡ 3 å€

```python
# === LangGraph å®ç° (ä¸²è¡Œ, 1.5ç§’) ===
def ocr_node(state):
    state["ocr"] = extract_text(state["screenshot"])  # 0.5s
    return state

def ui_node(state):
    state["ui"] = detect_ui(state["screenshot"])     # 0.5s
    return state

def vision_node(state):
    state["vision"] = analyze(state["screenshot"])   # 0.5s
    return state

graph.add_edge("ocr", "ui")      # å¿…é¡»ä¸²è¡Œ
graph.add_edge("ui", "vision")   # æ€»è®¡ 1.5 ç§’

# === è‡ªç ”æ¡†æ¶ (å¹¶è¡Œ, 0.5ç§’) ===
async def perceive():
    ocr, ui, vision = await asyncio.gather(
        extract_text(screenshot),   # åŒæ—¶æ‰§è¡Œ
        detect_ui(screenshot),       # åŒæ—¶æ‰§è¡Œ
        analyze(screenshot)          # åŒæ—¶æ‰§è¡Œ
    )
    return Perception(ocr, ui, vision)  # æ€»è®¡ 0.5 ç§’
```

**ç»“æœ**: æ„ŸçŸ¥é€Ÿåº¦æå‡ **3 å€**ï¼

---

### 4.2 å³æ—¶åé¦ˆ - ä»£ç ç®€æ´ 5 å€

```python
# === LangGraph å®ç° (5 ä¸ªèŠ‚ç‚¹, å¤æ‚) ===
def execute_node(state):
    state["screenshot_before"] = device.screenshot()
    device.execute(state["action"])
    return state

def wait_node(state):
    time.sleep(0.5)
    return state

def capture_after_node(state):
    state["screenshot_after"] = device.screenshot()
    return state

def judge_node(state):
    state["judgment"] = judge(
        state["screenshot_before"],
        state["screenshot_after"]
    )
    return state

def route_result(state):
    if state["judgment"] == "failed":
        return "retry"
    return "next"

graph.add_edge("execute", "wait")
graph.add_edge("wait", "capture_after")
graph.add_edge("capture_after", "judge")
graph.add_conditional_edges("judge", route_result)

# === è‡ªç ”æ¡†æ¶ (1 ä¸ªå‡½æ•°, ç®€æ´) ===
async def execute_with_feedback(action):
    before = device.screenshot()
    device.execute(action)
    await asyncio.sleep(0.5)
    after = device.screenshot()

    if is_failed(before, after):
        device.press_back()  # ç«‹å³çº é”™
        return retry()

    return success()
```

**ç»“æœ**: ä»£ç ç®€æ´ **5 å€**ï¼Œå¯è¯»æ€§ **10 å€**ï¼

---

### 4.3 æŒç»­è§‚å¯Ÿ - LangGraph æ— æ³•å®ç°

```python
# === LangGraph: æ— æ³•å®ç°åå°ä»»åŠ¡ ===
# âŒ èŠ‚ç‚¹éƒ½æ˜¯åŒæ­¥è°ƒç”¨ï¼Œæ— æ³•å¯åŠ¨åå°ä»»åŠ¡
# âŒ å¦‚æœæŠŠè§‚å¯Ÿä¹Ÿå»ºæ¨¡æˆèŠ‚ç‚¹ï¼Œä¼šé˜»å¡ä¸»æµç¨‹

# === è‡ªç ”æ¡†æ¶: è‡ªç„¶å®ç° ===
async def main_loop():
    # å¯åŠ¨åå°è§‚å¯Ÿ
    observer = asyncio.create_task(continuous_observe())

    # ä¸»å¾ªç¯
    while not done:
        await execute_step()

    # æ¸…ç†
    observer.cancel()

async def continuous_observe():
    """åå°æŒç»­ç›‘æ§"""
    while True:
        events = detect_events()
        if events.popup:
            close_popup()
        await asyncio.sleep(0.5)
```

**ç»“æœ**: LangGraph **æ— æ³•å®ç°**ï¼Œè‡ªç ”æ¡†æ¶ **è½»æ¾æå®š**ï¼

---

## äº”ã€æŠ€æœ¯é€‰å‹

### 5.1 æ ¸å¿ƒä¾èµ–

```toml
[dependencies]
# ä¸éœ€è¦ LangGraphï¼
# langgraph = ">=0.2.0"  âŒ åˆ é™¤
# langchain = ">=0.3.0"  âŒ åˆ é™¤

# å¼‚æ­¥æ¡†æ¶ (Python å†…ç½®)
# asyncio - å¹¶å‘ã€åå°ä»»åŠ¡

# å‘é‡æ£€ç´¢
lancedb = ">=0.25.2"        # è½»é‡çº§å‘é‡æ•°æ®åº“

# Android æ§åˆ¶
adbutils = ">=2.10.2"
droidrun = ">=0.3.9"

# LLM é›†æˆ
openai = ">=1.99.1"         # API å®¢æˆ·ç«¯
anthropic = ">=0.67.0"      # Claude

# æ•°æ®æ¨¡å‹
pydantic = ">=2.11.10"

# å·¥å…·
rich = ">=14.1.0"           # ç»ˆç«¯ç¾åŒ–
loguru = ">=0.7.0"          # æ—¥å¿—
pyyaml = ">=6.0"            # é…ç½®
```

### 5.2 å¯é€‰ä¾èµ–

```toml
[project.optional-dependencies]
# VL æ¨¡å‹
vision = [
    "transformers>=4.50.0",
    "torch>=2.5.0",
]

# å¼€å‘å·¥å…·
dev = [
    "pytest>=8.0.0",
    "pytest-asyncio>=0.25.0",
    "black>=23.0.0",
    "ruff>=0.13.0",
]

# å¯è§†åŒ–
viz = [
    "graphviz>=0.20.0",  # ç”Ÿæˆæ‰§è¡Œæµç¨‹å›¾
]
```

---

## å…­ã€é…ç½®ç®¡ç†

### 6.1 é…ç½®æ–‡ä»¶

```yaml
# configs/default.yaml
app:
  name: "DroidRun-VL"
  version: "2.0.0"
  framework: "self-developed"  # æ ‡æ³¨è‡ªç ”æ¡†æ¶

# LLM é…ç½®
llm:
  provider: "openai"
  model: "gpt-4o"
  temperature: 0.7
  max_tokens: 2000

# æ„ŸçŸ¥ç³»ç»Ÿé…ç½®
perception:
  enable_parallel: true          # å¯ç”¨å¹¶å‘æ„ŸçŸ¥
  parallel_timeout: 2.0          # å¹¶å‘è¶…æ—¶ (ç§’)
  vision_model: "Qwen3-VL-4B"

  # æŒç»­è§‚å¯Ÿé…ç½®
  continuous_observe:
    enabled: true
    interval: 0.5                # è§‚å¯Ÿé—´éš” (ç§’)
    auto_close_popup: true       # è‡ªåŠ¨å…³é—­å¼¹çª—

# å†³ç­–ç³»ç»Ÿé…ç½®
decision:
  enable_cot: true               # å¯ç”¨ CoT æ¨ç†
  enable_metacognition: true     # å¯ç”¨å…ƒè®¤çŸ¥
  high_risk_threshold: 0.7       # é«˜é£é™©é˜ˆå€¼
  candidate_count: 3             # å€™é€‰æ–¹æ¡ˆæ•°é‡

# æ‰§è¡Œç³»ç»Ÿé…ç½®
execution:
  feedback_wait_time: 0.5        # åé¦ˆç­‰å¾…æ—¶é—´ (ç§’)
  auto_retry: true               # è‡ªåŠ¨é‡è¯•
  max_retry: 2                   # æœ€å¤§é‡è¯•æ¬¡æ•°

# è®°å¿†ç³»ç»Ÿé…ç½®
memory:
  working_memory_size: 7         # å·¥ä½œè®°å¿†å®¹é‡
  enable_loop_detection: true    # å¯ç”¨å¾ªç¯æ£€æµ‹
  loop_threshold: 3              # å¾ªç¯åˆ¤å®šé˜ˆå€¼

  # é•¿æœŸè®°å¿†é…ç½®
  long_term:
    db_path: "data/experiences/vector_db"
    retention_days: 90
    min_success_rate: 0.7        # æœ€ä½æˆåŠŸç‡

# è®¾å¤‡é…ç½®
device:
  adb_host: "127.0.0.1"
  adb_port: 5037
  screenshot_format: "png"
  screenshot_quality: 90
```

---

## ä¸ƒã€å¼€å‘è·¯çº¿å›¾

### Phase 1: æ ¸å¿ƒè®¤çŸ¥å¾ªç¯ (1-2 å‘¨)

```
âœ… ç›®å½•ç»“æ„æ­å»º
âœ… åŸºç¡€æ¨¡å‹å®šä¹‰ (Task, Action, Perception)
âœ… å¹¶å‘æ„ŸçŸ¥ç³»ç»Ÿ (PerceptionFusion)
âœ… ç®€å•å†³ç­–å™¨ (DecisionMaker)
âœ… åŠ¨ä½œæ‰§è¡Œå™¨ (ActionExecutor)
âœ… å³æ—¶åé¦ˆæ§åˆ¶å™¨ (FeedbackController)
âœ… å·¥ä½œè®°å¿† (WorkingMemory)
âœ… Worker Agent åŸºç¡€ç‰ˆ
```

**éªŒè¯ç›®æ ‡**: å®Œæˆå•ä¸ªç®€å•ä»»åŠ¡ (å¦‚: "æ‰“å¼€è®¾ç½®")

---

### Phase 2: åŒå±‚æ¶æ„ (2-3 å‘¨)

```
âœ… Master Agent å®ç°
âœ… ä»»åŠ¡åˆ†è§£ (LLM)
âœ… Worker ç›‘ç£æœºåˆ¶
âœ… å¼‚å¸¸æ£€æµ‹ (å¡æ­»/å¾ªç¯)
âœ… æ¢å¤ç­–ç•¥æ§åˆ¶å™¨
âœ… æŒç»­è§‚å¯Ÿå™¨ (åå°ä»»åŠ¡)
```

**éªŒè¯ç›®æ ‡**: å®Œæˆå¤æ‚ä»»åŠ¡ + å¼‚å¸¸æ¢å¤ (å¦‚: "åˆ°é—²é±¼è´­ä¹°ç¡¬ç›˜ï¼Œå¤„ç†è¯¯è§¦é€€å‡º")

---

### Phase 3: è®°å¿†ç³»ç»Ÿ (2-3 å‘¨)

```
âœ… é•¿æœŸè®°å¿†å­˜å‚¨ (LanceDB)
âœ… ç»éªŒæ£€ç´¢å™¨
âœ… ç»éªŒå­¦ä¹ æœºåˆ¶
âœ… ç©ºé—´è®°å¿† (é¡µé¢å¯¼èˆªå›¾)
âœ… ç»éªŒå¤ç”¨é€»è¾‘
```

**éªŒè¯ç›®æ ‡**: ç¬¬äºŒæ¬¡æ‰§è¡Œç›¸åŒä»»åŠ¡é€Ÿåº¦æå‡ 5 å€

---

### Phase 4: é«˜çº§ç‰¹æ€§ (2-3 å‘¨)

```
âœ… å…ƒè®¤çŸ¥ç›‘æ§
âœ… åŠ¨æ€é‡è§„åˆ’
âœ… å¾ªç¯ä»»åŠ¡è°ƒåº¦
âœ… æ€§èƒ½ä¼˜åŒ–
âœ… å¯è§†åŒ–å·¥å…· (Mermaid æµç¨‹å›¾)
âœ… å®Œæ•´æµ‹è¯•è¦†ç›–
```

**éªŒè¯ç›®æ ‡**: å¾ªç¯ä»»åŠ¡ 24 å°æ—¶ç¨³å®šè¿è¡Œ

---

## å…«ã€å¿«é€Ÿå¼€å§‹ç¤ºä¾‹

### 8.1 ç®€å•ä»»åŠ¡

```python
# examples/simple_task.py
import asyncio
from src.core.master_agent import MasterAgent
from src.core.worker_agent import WorkerAgent
from src.models.task import Task

async def main():
    # 1. åˆå§‹åŒ– Agent
    worker = WorkerAgent(...)
    master = MasterAgent(worker)

    # 2. åˆ›å»ºä»»åŠ¡
    task = Task(description="æ‰“å¼€è®¾ç½®")

    # 3. æ‰§è¡Œ
    result = await master.execute_task(task)

    # 4. æŸ¥çœ‹ç»“æœ
    print(f"ä»»åŠ¡çŠ¶æ€: {result.status}")
    print(f"æ‰§è¡Œæ­¥æ•°: {result.steps}")

if __name__ == "__main__":
    asyncio.run(main())
```

### 8.2 å¤æ‚ä»»åŠ¡ + å¼‚å¸¸æ¢å¤

```python
# examples/recovery_demo.py
import asyncio
from src.core.master_agent import MasterAgent
from src.models.task import Task

async def main():
    master = MasterAgent(...)

    # å¤æ‚ä»»åŠ¡
    task = Task(description="åˆ°é—²é±¼è´­ä¹° 200 å…ƒä»¥å†…çš„ 1TB ç¡¬ç›˜")

    # æ‰§è¡Œ (Master ä¼šè‡ªåŠ¨å¤„ç†å¼‚å¸¸)
    result = await master.execute_task(task)

    # æŸ¥çœ‹æ‰§è¡Œæ—¥å¿—
    print(f"ä»»åŠ¡å®Œæˆ: {result.status}")
    print(f"å¼‚å¸¸æ¬¡æ•°: {result.recovery_count}")
    print(f"æ€»è€—æ—¶: {result.duration}ç§’")

asyncio.run(main())
```

### 8.3 å¾ªç¯ä»»åŠ¡

```python
# examples/loop_task.py
import asyncio
from src.core.master_agent import MasterAgent
from src.models.task import Task

async def main():
    master = MasterAgent(...)

    # å¾ªç¯ä»»åŠ¡
    task = Task(
        description="è®¿é—® Twitterï¼Œéšæœºæµè§ˆè´´æ–‡å¹¶å–„æ„å›å¤",
        loop=True,           # æ ‡è®°ä¸ºå¾ªç¯ä»»åŠ¡
        max_iterations=100   # æœ€å¤šæ‰§è¡Œ 100 æ¬¡
    )

    # æ‰§è¡Œ (æ°¸ä¸åœæ­¢ï¼Œé™¤éæ‰‹åŠ¨ä¸­æ–­)
    await master.execute_task(task)

asyncio.run(main())
```

---

## ä¹ã€æ ¸å¿ƒä¼˜åŠ¿æ€»ç»“

### 9.1 vs LangGraph

| ç»´åº¦ | LangGraph | è‡ªç ”æ¡†æ¶ | ä¼˜åŠ¿å€æ•° |
|------|-----------|---------|---------|
| å¹¶å‘æ„ŸçŸ¥é€Ÿåº¦ | 1.5ç§’ (ä¸²è¡Œ) | 0.5ç§’ (å¹¶è¡Œ) | **3x** |
| å³æ—¶åé¦ˆä»£ç é‡ | 50 è¡Œ (5 èŠ‚ç‚¹) | 10 è¡Œ (1 å‡½æ•°) | **5x** |
| æŒç»­è§‚å¯Ÿ | âŒ æ— æ³•å®ç° | âœ… è½»æ¾å®ç° | **âˆ** |
| å…ƒè®¤çŸ¥ç›‘æ§ | âŒ éš¾ä»¥å®ç° | âœ… è‡ªç„¶å®ç° | **âˆ** |
| åŠ¨æ€é‡è§„åˆ’ | âŒ é™æ€å›¾ | âœ… ä»»æ„è·³è½¬ | **âˆ** |
| å¼€å‘è‡ªç”±åº¦ | âš ï¸ å—æ¡†æ¶é™åˆ¶ | âœ… å®Œå…¨è‡ªç”± | **âˆ** |

### 9.2 æ ¸å¿ƒä»·å€¼

1. âœ… **æ€§èƒ½æœ€ä¼˜**: å¹¶å‘æ„ŸçŸ¥ + å¼‚æ­¥æ‰§è¡Œ
2. âœ… **ä»£ç ç®€æ´**: é€»è¾‘æ¸…æ™°ï¼Œæ˜“äºç»´æŠ¤
3. âœ… **å®Œå…¨æ§åˆ¶**: æƒ³æ€ä¹ˆå†™å°±æ€ä¹ˆå†™
4. âœ… **æŠ€æœ¯è‡ªä¸»**: ä¸ä¾èµ–å¤–éƒ¨æ¡†æ¶
5. âœ… **æ˜“äºæ‰©å±•**: éšæ—¶æ·»åŠ æ–°åŠŸèƒ½

---

## åã€å…³é”®åŸåˆ™

1. **å¼‚æ­¥ä¼˜å…ˆ**: æ‰€æœ‰ I/O æ“ä½œä½¿ç”¨ `async/await`
2. **å¹¶å‘æ€ç»´**: èƒ½å¹¶å‘å°±å¹¶å‘ï¼Œå……åˆ†åˆ©ç”¨èµ„æº
3. **å³æ—¶åé¦ˆ**: æ‰§è¡Œåç«‹å³åˆ¤æ–­ï¼Œå¿«é€Ÿçº é”™
4. **è®°å¿†é©±åŠ¨**: å·¥ä½œè®°å¿† + é•¿æœŸè®°å¿†åŒé‡ä¿éšœ
5. **å…ƒè®¤çŸ¥**: é«˜é£é™©å†³ç­–äºŒæ¬¡éªŒè¯
6. **æ¨¡å—åŒ–**: æ¯ä¸ªæ¨¡å—ç‹¬ç«‹ï¼Œä½è€¦åˆé«˜å†…èš
7. **å¯æµ‹è¯•**: æ‰€æœ‰æ ¸å¿ƒé€»è¾‘å•å…ƒæµ‹è¯•è¦†ç›–
8. **å¯è§‚æµ‹**: è¯¦ç»†æ—¥å¿— + æ€§èƒ½æŒ‡æ ‡

---

## é™„å½•: ä¸é¡¶å±‚æ¶æ„æ–‡æ¡£å¯¹åº”å…³ç³»

| é¡¶å±‚æ¶æ„æ¦‚å¿µ | ä»£ç å®ç° |
|------------|---------|
| Master Agent | `core/master_agent.py` |
| Worker Agent | `core/worker_agent.py` |
| è§‚å¯Ÿâ†’æ€è€ƒâ†’å†³ç­–â†’æ‰§è¡Œâ†’åé¦ˆ | `core/cognitive_loop.py` |
| å¹¶å‘æ„ŸçŸ¥ | `perception/fusion.py` |
| æŒç»­è§‚å¯Ÿ | `perception/screen_observer.py` |
| å³æ—¶åé¦ˆ | `execution/feedback_controller.py` |
| å·¥ä½œè®°å¿† | `memory/working_memory.py` |
| é•¿æœŸè®°å¿† | `memory/long_term_memory.py` |
| å…ƒè®¤çŸ¥ | `decision/metacognition.py` |
| å¼‚å¸¸æ¢å¤ | `execution/recovery.py` |

---

**æ–‡æ¡£ç»“è®º**: è‡ªç ”æ¡†æ¶æ˜¯å”¯ä¸€æ­£ç¡®é€‰æ‹©ï¼ŒLangGraph å·²è¢«æ·˜æ±°ï¼ğŸ¯

**ä¸‹ä¸€æ­¥**: å¼€å§‹ Phase 1 å¼€å‘ï¼Œæ­å»ºæ ¸å¿ƒè®¤çŸ¥å¾ªç¯
